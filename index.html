<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="description" content="Hagius Breathing - A breathing exercise app for stress reduction and mindfulness" />
  <title>Hagius Breathing</title>
  
  <!-- PWA Meta Tags -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#214B7A">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Hagius Breathing">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">

  <!-- iOS splash screen images -->
  <link rel="apple-touch-startup-image" href="icons/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="icons/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  
  <style>
    /* Reset & Base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-color: #214B7A;
      --secondary-color: #F28E47;
      --white-transparent-light: rgba(255, 255, 255, 0.2);
      --white-transparent-medium: rgba(255, 255, 255, 0.3);
      --white-transparent-bright: rgba(255, 255, 255, 0.4);
      --white-transparent-brighter: rgba(255, 255, 255, 0.5);
      --border-radius: 0px;
      --transition-speed: 0.3s;
      --safe-bottom: calc(20px + env(safe-area-inset-bottom));
      --safe-top: calc(20px + env(safe-area-inset-top));
      --button-spacing: 4px; /* Consistent spacing throughout the app */
      --element-height: 60px;
      --font-size-button: 0.4; /* Standardized font size for all UI elements */
      --font-size-header: 2.4rem;
      --element-padding: 15px;
      --min-button-width: 120px; /* Minimum width for buttons before wrapping */
    }
    
    html {
      height: 100vh; /* Use viewport height */
      overflow: hidden; /* Prevent scrolling */
    }
    
    body {
      font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      font-weight: bold;
      background: linear-gradient(to bottom, var(--primary-color), var(--secondary-color));
      color: #fff;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100vh;
      width: 100%;
      margin: 0;
      padding-bottom: env(safe-area-inset-bottom);
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      overflow: hidden;
      touch-action: manipulation; /* Optimize for touch to reduce delay */
    }
    
    /* Loading Animation */
    .loading-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, var(--primary-color), var(--secondary-color));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
      flex-direction: column;
    }
    
    .loading-logo {
      margin-bottom: 20px;
    }
    
    .loading-progress {
      width: 200px;
      height: 4px;
      background: var(--white-transparent-light);
      margin-top: 20px;
      overflow: hidden;
      border-radius: 2px;
    }
    
    .loading-bar {
      height: 100%;
      width: 0%;
      background: white;
      transition: width 0.3s ease;
    }
    
    .loader-text {
      text-align: center;
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      margin-top: 20px;
      text-transform: uppercase;
    }
    
    /* Hide content until loaded */
    .app-container {
      opacity: 0;
      transition: opacity 0.5s ease-in;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    
    /* Completion Modal */
    .completion-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .completion-modal.visible {
      opacity: 1;
    }
    
    .modal-content {
      background: var(--white-transparent-light);
      padding: 30px;
      max-width: 90%;
      width: 350px;
      text-align: center;
      transform: translateY(20px);
      transition: transform 0.3s ease;
    }
    
    .completion-modal.visible .modal-content {
      transform: translateY(0);
    }
    
    .modal-content h2 {
      margin-bottom: 15px;
      font-size: 1.8rem;
    }
    
    .modal-content p {
      margin-bottom: 20px;
      opacity: 0.9;
    }
    
    .modal-content button {
      background: var(--white-transparent-medium);
      border: none;
      padding: 0 var(--element-padding);
      color: white;
      font-weight: bold;
      font-size: calc(var(--element-height) * var(--font-size-button));
      width: 100%;
      height: var(--element-height);
      line-height: var(--element-height);
      cursor: pointer;
      transition: background 0.2s ease;
      text-transform: uppercase;
    }
    
    .modal-content button:hover {
      background: var(--white-transparent-bright);
    }
    
    /* Header */
    .header {
      position: fixed;
      top: 10%;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 10;
      transition: opacity 0.3s ease;
    }
    
    .focus-mode .header {
      opacity: 0;
      pointer-events: none;
    }
    
    .logo {
      max-width: 180px;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    
    /* Main Container */
    .main-container {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      width: 100%;
    }
    
    /* Breathing Circle - FIXED */
    .breathing-circle {
      width: 250px;
      height: 250px;
      border-radius: 50%;
      background: var(--white-transparent-light);
      margin: 0 auto;
      will-change: transform;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: scale(1);
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
      position: relative;
      z-index: 1; /* Ensure proper stacking */
      overflow: visible; /* Allow the timer to be visible */
    }
    
    
/* Breath Hold Loading Indicator - FIXED */
.hold-progress {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 0; /* Place behind circle content */
}

.hold-progress svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: visible; /* Allow stroke to extend past container */
  background: transparent; /* Ensure no background color */
}

.hold-progress circle {
  fill: none;
  stroke: rgba(255, 255, 255, 0.7);
  stroke-width: 15px; /* Increased to match button height proportionally */
  stroke-linecap: butt; /* Changed from round to butt for sharp ends */
  transform-origin: center;
  transform: rotate(-90deg);
  /* Perfect edge alignment */
  cx: 50;
  cy: 50;
  r: 42.5; /* Adjusted for thicker stroke width */
  stroke-dasharray: 267; /* 2 * Ï€ * 42.5 */
  stroke-dashoffset: 0;
}

/* Safari-specific fix for breath hold progress */
@media not all and (min-resolution:.001dpcm) { 
    @supports (-webkit-appearance:none) {
        .hold-progress svg {
            width: 101%; /* Slightly larger to account for Safari rendering */
            height: 101%;
            left: -0.5%;
            top: -0.5%;
        }
        
        .hold-progress circle {
            r: 43; /* Slight adjustment for Safari */
            stroke-dasharray: 270.2; /* Recalculated circumference */
        }
    }
}
    
    /* Timer - FIXED */
    .timer {
      font-size: calc(var(--element-height) * 0.4);
      font-weight: bold;
      color: rgba(255, 255, 255, 0.9);
      text-align: center;
      transition: opacity 0.15s ease-in-out;
      text-transform: uppercase;
      position: relative;
      z-index: 2; /* Ensure timer is above other elements */
    }
    
    .timer.fade {
      opacity: 0.3;
    }
    
    .focus-mode .timer {
      opacity: 0;
    }
    

    /* Session Progress Bar */
    .session-progress-container {
      position: fixed;
      bottom: calc(var(--element-height) + var(--button-spacing) + env(safe-area-inset-bottom));
      left: 0;
      right: 0;
      width: 100%;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
      margin-bottom: 0; /* Ensure exact 4px spacing */
    }
    
    .session-progress {
      width: 100%;
      height: var(--element-height);
      background: var(--white-transparent-light);
      overflow: hidden;
      cursor: pointer;
      transition: background var(--transition-speed);
      position: relative;
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    }
    
    .session-progress:hover {
      background: var(--white-transparent-bright);
    }
    
    .session-progress-bar {
      height: 100%;
      background: var(--white-transparent-brighter);
      width: 0%;
      transition: width 1s linear;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
      will-change: width; /* Optimize animation performance */
    }
    
    .remaining-time {
      position: absolute;
      font-size: calc(var(--element-height) * 0.4);
      font-weight: bold;
      color: white;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      transition: opacity 0.3s ease;
    }
    
    .focus-mode .remaining-time {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Timer Options */
    .timer-options {
      position: fixed;
      bottom: calc(2 * var(--element-height) + 2 * var(--button-spacing) + env(safe-area-inset-bottom));
      left: 0;
      right: 0;
      display: none;
      z-index: 30;
    }
    
    .timer-option-buttons {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      position: relative;
      margin: 0;
      padding: 0;
      gap: var(--button-spacing);
    }
    
    .timer-options button {
      background: var(--white-transparent-light);
      border: none;
      color: white;
      padding: 0 var(--element-padding);
      flex: 1 1 calc(25% - var(--button-spacing) * 3/4); /* Equal distribution for 4 buttons */
      min-width: 0;
      max-width: none;
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      cursor: pointer;
      transition: background var(--transition-speed);
      margin: 0;
      height: var(--element-height);
      line-height: var(--element-height);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* Media query for narrower screens */
    @media (max-width: 600px) {
      .timer-options button {
        flex: 1 1 calc(50% - var(--button-spacing) * 1/2); /* 2 per row */
      }
    }
    
    @media (max-width: 320px) {
      .timer-options button {
        flex: 1 1 100%; /* 1 per row for very small screens */
      }
    }
    
    .timer-options button:hover {
      background: var(--white-transparent-medium);
    }
    
    .timer-options button.active {
      background: var(--white-transparent-medium);
    }
    
    /* Button Container */
    .button-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      z-index: 10;
      padding: 0 0 env(safe-area-inset-bottom) 0;
      gap: var(--button-spacing); /* Consistent 4px spacing */
    }
    
    /* Bottom Buttons */
    .bottom-button {
      background: var(--white-transparent-light);
      border: none;
      flex: 1;
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      color: #fff;
      cursor: pointer;
      transition: background var(--transition-speed);
      height: var(--element-height);
      line-height: var(--element-height);
      padding: 0 var(--element-padding);
      text-transform: uppercase;
      margin: 0;
      min-width: 0; /* Allow shrinking */
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }
    
    .bottom-button:focus {
      outline: 2px solid #fff;
    }
    
    .bottom-button:hover {
      background: var(--white-transparent-bright);
    }
    
    /* Technique Panel */
    .technique-panel {
      position: fixed;
      bottom: calc(2 * var(--element-height) + 2 * var(--button-spacing) + env(safe-area-inset-bottom));
      left: 0;
      right: 0;
      display: none;
      z-index: 50;
    }
    
    .technique-buttons {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      gap: var(--button-spacing);
    }
    
    /* Default layout - 3 buttons in top row, 2 in bottom */
    .technique-panel button {
      flex: 1 1 calc(33.33% - var(--button-spacing) * 2/3);
      min-width: 80px; /* Ensures buttons don't get too small */
    }
    
    .technique-panel button:nth-child(4),
    .technique-panel button:nth-child(5) {
      flex: 1 1 calc(50% - var(--button-spacing) * 1/2);
    }
    
    /* Medium screens - 2 buttons per row where possible */
    @media (max-width: 600px) {
      .technique-panel button {
        flex: 1 1 calc(50% - var(--button-spacing) * 1/2);
      }
      
      /* If needed, the rightmost button will wrap */
      .technique-buttons {
        justify-content: flex-start;
      }
    }
    
    /* Even on narrow screens, maintain equal widths per row */
    @media (max-width: 320px) {
      .technique-panel button {
        flex: 1 1 auto; /* Allow natural sizing */
        min-width: calc(50% - var(--button-spacing)); /* Two per row minimum */
      }
    }
    
    .technique-panel button, 
    .technique-panel .learn-more {
      background: var(--white-transparent-light);
      border: none;
      color: white;
      padding: 0 var(--element-padding);
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      text-align: center;
      cursor: pointer;
      transition: background var(--transition-speed);
      margin: 0;
      text-transform: capitalize;
      height: var(--element-height);
      line-height: var(--element-height);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-tap-highlight-color: transparent;
    }
    
    .technique-panel button:hover, 
    .technique-panel .learn-more:hover {
      background: var(--white-transparent-medium);
    }
    
    /* Knowledge Section */
    #knowledgeSection {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, var(--primary-color), var(--secondary-color));
      z-index: 100;
      overflow-y: auto;
      padding: var(--safe-top) 0 calc(70px + env(safe-area-inset-bottom)) 0;
    }
    
    .knowledge-header {
      text-align: center;
      margin-bottom: 30px;
      padding: 0 20px;
    }
    
    .knowledge-header .logo {
      margin-bottom: 15px;
    }
    
    .knowledge-header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }
    
    .knowledge-nav {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      margin-bottom: var(--button-spacing); /* Exactly 4px spacing to content below */
      padding: 0;
      gap: var(--button-spacing);
    }
    
    .knowledge-nav button {
      background: var(--white-transparent-light);
      border: none;
      padding: 0 var(--element-padding);
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      color: #fff;
      cursor: pointer;
      transition: background var(--transition-speed);
      flex: 1 1 calc(20% - var(--button-spacing) * 4/5); /* Equal width for 5 buttons */
      min-width: 0;
      max-width: none;
      margin: 0;
      height: var(--element-height);
      line-height: var(--element-height);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* Media queries for responsive layout */
    @media (max-width: 768px) {
      .knowledge-nav button {
        flex: 1 1 calc(33.333% - var(--button-spacing) * 2/3); /* 3 per row */
      }
    }
    
    @media (max-width: 480px) {
      .knowledge-nav button {
        flex: 1 1 calc(50% - var(--button-spacing) * 1/2); /* 2 per row */
      }
    }
    
    @media (max-width: 320px) {
      .knowledge-nav button {
        flex: 1 1 100%; /* Stack buttons on very small screens */
      }
    }
    
    .knowledge-nav button:hover, 
    .knowledge-nav button.active {
      background: var(--white-transparent-bright);
    }
    
    .knowledge-content {
      background: var(--white-transparent-light);
      padding: 20px;
      margin: 0;
      width: 100%;
    }
    
    .technique-info {
      display: none;
    }
    
    .technique-info.active {
      display: block;
    }
    
    .technique-info h2 {
      font-size: 1.8rem;
      margin-bottom: 15px;
    }
    
    .technique-info h3 {
      font-size: 1.3rem;
      margin: 20px 0 10px;
    }
    
    .technique-info p, 
    .technique-info ul, 
    .technique-info ol {
      margin-bottom: 15px;
      line-height: 1.6;
    }
    
    .technique-info ul, 
    .technique-info ol {
      padding-left: 25px;
    }
    
    .back-button {
      position: fixed;
      top: var(--safe-top);
      left: 0;
      background: var(--white-transparent-light);
      border: none;
      border-radius: var(--border-radius);
      padding: 0 var(--element-padding);
      font-size: calc(var(--element-height) * var(--font-size-button));
      font-weight: bold;
      color: #fff;
      cursor: pointer;
      transition: background var(--transition-speed);
      z-index: 110;
      height: var(--element-height);
      line-height: var(--element-height);
      -webkit-tap-highlight-color: transparent;
      text-transform: uppercase;
    }
    
    .back-button:hover {
      background: var(--white-transparent-bright);
    }
    
    /* Notification Toast */
    .toast-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 15px;
      z-index: 9000;
      pointer-events: none;
    }
    
    .toast {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 30px;
      margin-bottom: 10px;
      max-width: 80%;
      text-align: center;
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .toast.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Responsive Design */
    @media (min-width: 768px) {
      :root {
        --element-height: 70px;
        --font-size-button: 0.4; /* Standardized font size */
        --font-size-header: 3rem;
        --element-padding: 18px;
        --min-button-width: 140px;
      }
      .breathing-circle { width: 350px; height: 350px; }
      .logo { max-width: 240px; }
    }
    
    @media (max-width: 480px) {
      :root {
        --element-height: 50px;
        --font-size-button: 0.4; /* Standardized font size */
        --element-padding: 12px;
      }
      .breathing-circle { 
        width: 250px; 
        height: 250px; 
      }
    }
    
    /* Screen Reader Only */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Battery-saving mode (when document is hidden) */
    .battery-saving .breathing-circle {
      transition: transform 4s linear !important;
    }

    /* PWA Install Button */
    #installButton {
      display: none;
      background: var(--white-transparent-medium);
    }
    
    #installButton:hover {
      background: var(--white-transparent-bright);
    }
    
    /* iOS PWA Installation Tip */
    .ios-install-tip {
      position: fixed;
      bottom: calc(var(--element-height) * 2 + var(--button-spacing) * 2 + env(safe-area-inset-bottom) + 10px);
      left: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      z-index: 9999;
      animation: slide-up 0.3s ease;
    }
      
    .tip-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
      
    .ios-install-tip p {
      margin: 0;
      flex: 1;
    }
      
    .share-icon {
      display: inline-block;
      box-sizing: border-box;
      width: 18px;
      height: 18px;
      text-align: center;
      font-weight: bold;
      line-height: 18px;
      border: 1px solid white;
      border-radius: 4px;
      margin: 0 3px;
    }
      
    .close-tip {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0 5px;
    }
      
    @keyframes slide-up {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    /* Fix for iPhone PWA in standalone mode */
    @media all and (display-mode: standalone) {
      /* Fix for the white space at bottom */
      html, body {
        height: 100vh !important;
        width: 100vw !important;
        overflow: hidden !important;
      }
      
      /* Ensure the app container fills entire screen */
      .app-container {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: 100% !important;
        overflow: hidden !important;
      }
      
      /* Fix for bottom buttons container */
      .button-container {
        bottom: 0 !important;
        padding-bottom: env(safe-area-inset-bottom) !important;
      }
      
      /* Fix for session progress container */
      .session-progress-container {
        bottom: calc(var(--element-height) + var(--button-spacing) + env(safe-area-inset-bottom)) !important;
      }
    }

    /* Apply to prevent any potential iOS-specific rendering issues */
    @supports (-webkit-touch-callout: none) {
      body {
        /* iOS-specific styles */
        position: fixed;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
    }

    /* Enhanced features styles */
    /* Theme Button */
    .theme-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.2);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .theme-selector {
      position: absolute;
      top: 60px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      border-radius: 10px;
      padding: 10px;
      display: none;
    }
    
    .theme-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      margin: 5px;
      cursor: pointer;
      border: 2px solid transparent;
    }
    
    .theme-option.active {
      border-color: white;
    }

    /* Mood Modal */
    .mood-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    
    .mood-content {
      background: rgba(255,255,255,0.2);
      padding: 20px;
      border-radius: 10px;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }
    
    .mood-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }
    
    .mood-button {
      background: rgba(255,255,255,0.25);
      border: none;
      padding: 15px;
      font-size: 16px;
      color: white;
      border-radius: 5px;
      cursor: pointer;
    }
    
    .mood-button:hover {
      background: rgba(255,255,255,0.35);
    }

    /* Analytics Dashboard */
    .analytics-dashboard {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(to bottom, rgba(33, 75, 122, 0.95), rgba(242, 142, 71, 0.95));
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      padding: 20px;
      z-index: 9999;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .close-dashboard {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
    }
    
    .dashboard-stats {
      display: flex;
      justify-content: space-between;
      margin-bottom: 25px;
    }
    
    .stat-card {
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      flex: 1;
      margin: 0 5px;
    }
    
    .stat-number {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .technique-stat {
      margin-bottom: 12px;
    }
    
    .technique-name {
      margin-bottom: 5px;
      text-transform: capitalize;
    }
    
    .technique-bar-container {
      height: 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      position: relative;
    }
    
    .technique-bar {
      height: 100%;
      background: rgba(255,255,255,0.5);
      border-radius: 10px;
    }
    
    .technique-count {
      position: absolute;
      right: 10px;
      top: 0;
      line-height: 20px;
    }
    
    .dashboard-insights {
      margin-top: 25px;
    }
    
    .insights-list {
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 15px;
      list-style-type: none;
    }
    
    .insight-item {
      margin-bottom: 10px;
      position: relative;
      padding-left: 20px;
    }
    
    .insight-item:before {
      content: "â€¢";
      position: absolute;
      left: 0;
      color: rgba(255,255,255,0.8);
    }

    /* Voice Settings Modal */
    .voice-settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    
    .voice-settings-content {
      background: rgba(255,255,255,0.15);
      padding: 25px;
      border-radius: 10px;
      width: 90%;
      max-width: 400px;
    }
    
    .setting-group {
      margin-bottom: 20px;
    }
    
    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .voice-settings-content select, 
    .voice-settings-content input[type="range"] {
      width: 100%;
      background: rgba(255,255,255,0.2);
      border: none;
      height: 40px;
      color: white;
      padding: 0 10px;
      border-radius: 5px;
    }
    
    .voice-settings-content option {
      background: #214B7A;
    }
    
    .settings-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 25px;
    }
    
    .settings-buttons button {
      flex: 1;
      margin: 0 5px;
      padding: 12px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
    }
    
    .test-voice-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 10px;
      width: 100%;
      border-radius: 5px;
      cursor: pointer;
    }
    
    /* Toggle Switch */
    .toggle {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255,255,255,0.2);
      transition: .4s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: rgba(255,255,255,0.6);
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
  </style>
</head>
<body>
  <!-- Loading Animation -->
  <div id="loadingContainer" class="loading-container">
    <div>
      <img src="monogram.png" alt="Hagius" class="logo loading-logo">
      <div class="loader-text">Loading Breathing App...</div>
      <div class="loading-progress">
        <div id="loadingBar" class="loading-bar"></div>
      </div>
    </div>
  </div>

  <!-- Toast notification container -->
  <div id="toastContainer" class="toast-container"></div>

  <!-- App Container - hidden until loaded -->
  <div id="appContainer" class="app-container">
    <!-- Header fixed at the top -->
    <div class="header">
      <img src="logo.png" alt="Hagius" class="logo" id="mainLogo">
    </div>
    
    <!-- Main Container centered -->
    <div class="main-container">

      <!-- Breathing Circle (always animating) -->
      <div id="breathingCircle" class="breathing-circle" aria-label="Breathing animation">
        <div id="timer" class="timer" aria-live="polite">
          EXHALE
        </div>
        <!-- Hold progress indicator (circular loading bar) - FIXED SVG -->
        <div id="holdProgress" class="hold-progress" aria-hidden="true">
          <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
            <circle id="holdProgressCircle" cx="50" cy="50" r="42.5" stroke-dasharray="267" stroke-dashoffset="0" />
          </svg>
        </div>
      </div>
    </div>
    
    <!-- Timer Options - Appears when progress bar is clicked -->
    <div id="timerOptions" class="timer-options" aria-label="Timer duration options">
      <div class="timer-option-buttons">
        <button data-duration="5" aria-label="5 minute session">5 MIN</button>
        <button data-duration="10" aria-label="10 minute session">10 MIN</button>
        <button data-duration="15" aria-label="15 minute session">15 MIN</button>
        <button data-duration="20" aria-label="20 minute session">20 MIN</button>
      </div>
    </div>
    
    <!-- Technique Panel - Appears when technique button is clicked -->
    <div id="techniquePanel" class="technique-panel" aria-label="Breathing technique options">
      <div class="technique-buttons">
        <button data-technique="resonance" aria-label="Resonance breathing technique">Resonance</button>
        <button data-technique="478" aria-label="4-7-8 breathing technique">4-7-8</button>
        <button data-technique="box" aria-label="Box breathing technique">Box</button>
        <button data-technique="physio-sigh" aria-label="Physiological sigh breathing technique">Sighing</button>
        <button data-technique="learn-more" aria-label="Learn more about breathing techniques">Learn More</button>
      </div>
    </div>
    
    <!-- Session Progress Bar -->
    <div class="session-progress-container">
      <div id="progressBar" class="session-progress" role="progressbar" aria-label="Session progress">
        <div id="progressIndicator" class="session-progress-bar"></div>
        <div id="remainingTime" class="remaining-time" aria-live="polite">5:00</div>
      </div>
    </div>
    
    <!-- Bottom Button Container -->
    <div class="button-container" id="buttonContainer">
      <button id="techniqueButton" class="bottom-button" aria-haspopup="true" aria-expanded="false">Technique</button>
      <button id="focusButton" class="bottom-button" aria-pressed="false">Focus</button>
      <button id="installButton" class="bottom-button">Install App</button>
    </div>
    
    <!-- Knowledge Section (hidden by default) -->
    <div id="knowledgeSection" aria-hidden="true">
      <button class="back-button" id="backButton" aria-label="Back to breathing app">Back</button>
      
      <div class="knowledge-header">
        <img src="logo.png" alt="Hagius" class="logo">
      </div>
      
      <div class="knowledge-nav" role="tablist">
        <button class="technique-btn active" data-technique="basics" role="tab" aria-selected="true" aria-controls="basics-info">Basics</button>
        <button class="technique-btn" data-technique="resonance" role="tab" aria-selected="false" aria-controls="resonance-info">Resonance</button>
        <button class="technique-btn" data-technique="478" role="tab" aria-selected="false" aria-controls="478-info">4-7-8</button>
        <button class="technique-btn" data-technique="box" role="tab" aria-selected="false" aria-controls="box-info">Box</button>
        <button class="technique-btn" data-technique="physio-sigh" role="tab" aria-selected="false" aria-controls="physio-sigh-info">Sighing</button>
      </div>
      
      <div class="knowledge-content">
        <!-- Basics Info -->
        <div id="basics-info" class="technique-info active" role="tabpanel" aria-labelledby="basics-tab">
          <h2>Breathing Basics</h2>
          
          <p>Conscious breathing is one of the most powerful tools we have for managing stress, improving focus, and enhancing overall well-being. Understanding how breathing affects your mind and body is the first step in harnessing its potential.</p>
          
          <h3>The Science of Breathing</h3>
          <p>Your breath is the bridge between your conscious and unconscious processes. When you breathe, you activate your autonomic nervous system, which has two branches:</p>
          <ul>
            <li><strong>Sympathetic Nervous System</strong> - Your "fight or flight" response, activated by short, shallow breathing</li>
            <li><strong>Parasympathetic Nervous System</strong> - Your "rest and digest" response, activated by slow, deep breathing</li>
          </ul>
          
          <h3>Common Elements of Breathing Techniques</h3>
          <ul>
            <li><strong>Rate</strong> - How many breath cycles per minute</li>
            <li><strong>Depth</strong> - How deeply you inhale and exhale</li>
            <li><strong>Rhythm</strong> - The pattern of inhalation, holds, and exhalation</li>
            <li><strong>Pathway</strong> - Whether you breathe through your nose or mouth</li>
            <li><strong>Duration</strong> - How long you practice</li>
          </ul>
          
          <h3>Getting Started</h3>
          <p>For beginners, here are some tips to maximize the benefits of breathing practice:</p>
          <ul>
            <li>Start with just 5 minutes daily</li>
            <li>Practice in a comfortable seated position</li>
            <li>Breathe through your nose when possible</li>
            <li>Notice how different techniques make you feel</li>
            <li>Be patient - benefits increase with regular practice</li>
          </ul>
          
          <h3>When to Practice</h3>
          <p>Conscious breathing can be beneficial in many situations:</p>
          <ul>
            <li>First thing in the morning to set a calm tone for the day</li>
            <li>Before important meetings or events to reduce anxiety</li>
            <li>During stressful moments to regain composure</li>
            <li>Before meals to improve digestion</li>
            <li>Before bed to prepare for restful sleep</li>
          </ul>
        </div>
        <div id="resonance-info" class="technique-info" role="tabpanel" aria-labelledby="resonance-tab">
  <h2>Resonance Breathing</h2>
  
  <p>Resonance Breathing is a technique that synchronizes your breath with your heart rate, creating a state of cardiovascular coherence where your heart, lungs, and brain fall into a harmonious rhythm.</p>
  
  <h3>The Science</h3>
  <p>When you breathe at a rate of about 5-6 breaths per minute (inhaling and exhaling for about 5.5 seconds each), you create what scientists call "respiratory sinus arrhythmia" - a natural phenomenon where your heart rate increases slightly during inhalation and decreases during exhalation. This rhythm has profound effects on your autonomic nervous system:</p>
  <ul>
    <li>Enhances heart rate variability (HRV), a key indicator of cardiovascular health</li>
    <li>Optimizes the balance between sympathetic and parasympathetic nervous systems</li>
    <li>Improves gas exchange in the lungs and baroreflex sensitivity</li>
  </ul>
  
  <h3>How to Practice</h3>
  <ol>
    <li>Find a comfortable seated position with your spine straight</li>
    <li>Begin by observing your natural breath without changing it</li>
    <li>Gradually extend your inhalation to a count of 5.5 seconds</li>
    <li>Exhale gently for 5.5 seconds</li>
    <li>Continue this rhythm, keeping inhalation and exhalation equal</li>
    <li>Breathe through your nose if possible</li>
    <li>Practice for at least 5 minutes to experience benefits</li>
  </ol>
  
  <h3>Benefits</h3>
  <ul>
    <li>Reduces stress and anxiety</li>
    <li>Lowers blood pressure</li>
    <li>Improves cognitive function and focus</li>
    <li>Increases emotional regulation</li>
    <li>Enhances athletic recovery</li>
    <li>Improves sleep quality</li>
  </ul>
  
  <h3>When to Use</h3>
  <p>Resonance breathing is ideal for daily practice, particularly in these situations:</p>
  <ul>
    <li>Before important meetings or performances</li>
    <li>During periods of stress or overwhelm</li>
    <li>As part of a meditation practice</li>
    <li>Before bedtime to improve sleep quality</li>
    <li>When seeking to improve focus and concentration</li>
  </ul>
</div>
        <div id="478-info" class="technique-info" role="tabpanel" aria-labelledby="478-tab">
  <h2>4-7-8 Breathing</h2>
  
  <p>The 4-7-8 breathing technique, popularized by Dr. Andrew Weil, is a powerful tool for inducing relaxation and managing stress. It combines specific breath control with breath retention for a tranquilizing effect on the nervous system.</p>
  
  <h3>The Science</h3>
  <p>This technique works by activating several physiological mechanisms:</p>
  <ul>
    <li>The extended breath hold (7 seconds) increases carbon dioxide in your bloodstream, which has a naturally calming effect</li>
    <li>The long exhale (8 seconds) stimulates the parasympathetic nervous system, triggering the relaxation response</li>
    <li>The controlled breathing pattern interrupts anxiety cycles and distracts from racing thoughts</li>
    <li>The ratio creates slight air hunger that resets breathing patterns often disrupted by stress</li>
  </ul>
  
  <h3>How to Practice</h3>
  <ol>
    <li>Sit upright in a comfortable position</li>
    <li>Place the tip of your tongue against the tissue behind your upper front teeth throughout the exercise</li>
    <li>Exhale completely through your mouth, making a whoosh sound</li>
    <li>Close your mouth and inhale quietly through your nose to a count of 4</li>
    <li>Hold your breath for a count of 7</li>
    <li>Exhale completely through your mouth with a whoosh sound to a count of 8</li>
    <li>Repeat the cycle 3-4 times to start, gradually working up to 8 cycles</li>
  </ol>
  
  <h3>Benefits</h3>
  <ul>
    <li>Induces relaxation rapidly, often within one minute</li>
    <li>Reduces anxiety and stress</li>
    <li>Helps manage cravings and compulsive behaviors</li>
    <li>Lowers heart rate and blood pressure</li>
    <li>Improves sleep onset when practiced before bedtime</li>
    <li>Creates a "natural tranquilizer for the nervous system"</li>
  </ul>
  
  <h3>When to Use</h3>
  <p>The 4-7-8 technique is particularly effective for:</p>
  <ul>
    <li>Falling asleep quickly</li>
    <li>Returning to sleep if you wake during the night</li>
    <li>Managing moments of acute stress or anxiety</li>
    <li>Controlling emotional reactions in tense situations</li>
    <li>Reducing cravings when they arise</li>
    <li>Creating a quick reset during a busy day</li>
  </ul>
</div>
        <div id="box-info" class="technique-info" role="tabpanel" aria-labelledby="box-tab">
  <h2>Box Breathing</h2>
  
  <p>Box breathing, also known as square breathing or four-square breathing, is a simple yet powerful technique used by Navy SEALs, first responders, and high-performance athletes to induce calmness and enhance concentration.</p>
  
  <h3>The Science</h3>
  <p>Box breathing works through several mechanisms that directly affect your physiological state:</p>
  <ul>
    <li>The equal timing of each phase creates a stable, predictable rhythm that calms the nervous system</li>
    <li>The breath holds increase CO2 levels slightly, which helps regulate the autonomic nervous system</li>
    <li>The structured pattern engages the mind, preventing rumination and worry</li>
    <li>Regular practice strengthens the diaphragm and improves respiratory efficiency</li>
  </ul>
  
  <h3>How to Practice</h3>
  <ol>
    <li>Sit upright with a straight spine in a comfortable position</li>
    <li>Slowly exhale all air from your lungs</li>
    <li>Inhale slowly through your nose to a count of 4, feeling your lungs fill completely</li>
    <li>Hold your breath for a count of 4</li>
    <li>Exhale slowly through your mouth for a count of 4, emptying your lungs completely</li>
    <li>Hold your breath (lungs empty) for a count of 4</li>
    <li>Repeat the cycle at least 4 times, or up to 10 minutes for deeper effects</li>
  </ol>
  
  <h3>Benefits</h3>
  <ul>
    <li>Reduces stress and anxiety in high-pressure situations</li>
    <li>Improves concentration and focus</li>
    <li>Regulates blood pressure</li>
    <li>Builds mental resilience</li>
    <li>Enhances cognitive performance under stress</li>
    <li>Provides a mental reset when overwhelmed</li>
  </ul>
  
  <h3>When to Use</h3>
  <p>Box breathing is particularly effective in these situations:</p>
  <ul>
    <li>Before high-pressure events or performances</li>
    <li>During stressful situations to maintain composure</li>
    <li>When you need to clear your mind and regain focus</li>
    <li>As part of a preparation ritual for important tasks</li>
    <li>During transitions between activities in your day</li>
    <li>When you notice signs of stress or tension in your body</li>
  </ul>
</div>
        <div id="physio-sigh-info" class="technique-info" role="tabpanel" aria-labelledby="physio-sigh-tab">
  <h2>Physiological Sighing</h2>
  
  <p>Physiological sighing is a breathing pattern discovered by scientists at Stanford University that mimics the body's natural way of releasing stress and restoring optimal breathing. It involves a double inhale followed by a long exhale - just like a natural sigh.</p>
  
  <h3>The Science</h3>
  <p>Your body automatically employs sighing throughout the day to restore proper lung function, but you can consciously trigger this mechanism for immediate benefits:</p>
  <ul>
    <li>The double inhale ensures maximum inflation of alveoli (air sacs) in your lungs</li>
    <li>This counters the natural collapse of alveoli that occurs during shallow breathing</li>
    <li>The long exhale releases a significant amount of carbon dioxide</li>
    <li>This technique rapidly resets breathing patterns disrupted by stress</li>
    <li>Research shows it's more effective at reducing physiological arousal than other breathing techniques</li>
  </ul>
  
  <h3>How to Practice</h3>
  <ol>
    <li>Begin with a normal breath out, emptying your lungs comfortably</li>
    <li>Take a medium inhale through your nose</li>
    <li>Immediately take a second, shorter inhale to fill your lungs completely</li>
    <li>Exhale slowly and completely through your mouth</li>
    <li>Repeat 1-3 times for immediate relief, or up to 10 times for deeper relaxation</li>
  </ol>
  
  <h3>Benefits</h3>
  <ul>
    <li>Rapidly reduces physiological stress markers</li>
    <li>Decreases heart rate and blood pressure quickly</li>
    <li>Optimizes oxygen/carbon dioxide exchange</li>
    <li>Counters shallow breathing patterns</li>
    <li>Provides immediate relief from anxiety symptoms</li>
    <li>Takes less time than most breathing techniques (often just 30-60 seconds)</li>
  </ul>
  
  <h3>When to Use</h3>
  <p>Physiological sighing is particularly effective for:</p>
  <ul>
    <li>Moments of acute stress or panic</li>
    <li>When feeling overwhelmed or emotionally triggered</li>
    <li>Before challenging conversations or situations</li>
    <li>During short breaks to quickly reset your nervous system</li>
    <li>When you notice shallow breathing or breath-holding</li>
    <li>As a "first aid" breathing technique when you need immediate relief</li>
  </ul>
</div>
        <!-- Other technique info sections remain unchanged -->
      </div>
    </div>
  </div>
  
  <!-- Audio Cues - Preload for faster response -->
  <audio id="audioInhale" preload="auto"></audio>
  <audio id="audioHold" preload="auto"></audio>
  <audio id="audioExhale" preload="auto"></audio>
  
  <script>
    /**
     * Hagius Breathing App
     * Optimized JavaScript with improved performance, error handling, and organization
     */
    
    // Immediately-invoked function expression (IIFE) to encapsulate our code
    (function() {
      // CONSTANTS
      const AUDIO_SOURCES = {
        inhale: 'sounds/chime-inhale.mp3',
        hold: 'sounds/chime-hold.mp3',
        exhale: 'sounds/chime-exhale.mp3'
      };
      
      // HAPTIC PATTERNS (milliseconds)
      const HAPTIC_PATTERNS = {
        inhale: [100, 50, 100],     // Short pulse, pause, short pulse
        hold: [50],                  // Very short single vibration
        exhale: [200],               // Longer single vibration
        inhale2: [50, 30, 100],      // Special pattern for second inhale in physio-sigh
        sessionEnd: [100, 100, 100, 100, 300] // Pattern for session completion
      };
      
      const BREATHING_PATTERNS = {
        resonance: [
          { label: 'Inhale', duration: 5.5 },
          { label: 'Exhale', duration: 5.5 }
        ],
        box: [
          { label: 'Inhale', duration: 4 },
          { label: 'Hold',   duration: 4 },
          { label: 'Exhale', duration: 4 },
          { label: 'Hold',   duration: 4 }
        ],
        '478': [
          { label: 'Inhale', duration: 4 },
          { label: 'Hold',   duration: 7 },
          { label: 'Exhale', duration: 8 }
        ],
        'physio-sigh': [
          { label: 'Inhale', duration: 1 },
          { label: 'Inhale2', duration: 0.25 },
          { label: 'Exhale', duration: 2 }
        ]
      };
      
      // APP STATE
      const state = {
        currentPattern: BREATHING_PATTERNS.resonance,
        currentPhaseIndex: 0,
        currentPhaseTime: 0,
        phaseStartTime: 0,
        phaseEndTime: 0,
        animationFrameId: null,
        currentScale: 1.0,
        isFocusMode: false,
        sessionDuration: 5 * 60, // Default: 5 minutes in seconds
        sessionStartTime: 0,
        sessionEndTime: 0,
        sessionElapsed: 0,
        sessionIntervalId: null,
        isAudioReady: false,
        isVibrationSupported: 'vibrate' in navigator,
        hapticEnabled: true, // Default to enabled, can be toggled
        isVisible: true, // Document visibility state
        elements: {}, // Will store cached DOM elements
        loadedResources: {
          audio: false,
          dom: false
        },
        hasInteracted: false // Track if user has interacted (for autoplay policies)
      };
      
      // UTILITY FUNCTIONS
      const utils = {
        /**
         * Shows a toast notification
         * @param {string} message - Message to display
         * @param {number} duration - How long to show in ms
         */
        showToast: (message, duration = 3000) => {
          const toast = document.createElement('div');
          toast.className = 'toast';
          toast.textContent = message;
          
          state.elements.toastContainer.appendChild(toast);
          
          // Force reflow to enable transition
          void toast.offsetWidth;
          toast.classList.add('visible');
          
          setTimeout(() => {
            toast.classList.remove('visible');
            setTimeout(() => {
              toast.remove();
            }, 300); // Match transition duration
          }, duration);
        },
        
        /**
         * Format seconds into MM:SS display
         * @param {number} seconds - Seconds to format
         * @return {string} Formatted time string
         */
        formatTime: (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        },
        
        /**
         * Helper to safely toggle aria attributes
         * @param {HTMLElement} element - The element to modify
         * @param {string} attribute - The aria attribute to toggle
         * @param {boolean} value - The value to set
         */
        setAriaState: (element, attribute, value) => {
          if (element) {
            element.setAttribute(attribute, value.toString());
          }
        },
        
        /**
         * Check if battery optimization should be enabled
         * @returns {boolean} True if battery should be optimized
         */
        shouldOptimizeBattery: () => {
          // Check if document is hidden
          return !state.isVisible;
        },
        
        /**
         * Creates a debounced function that delays invoking func
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to delay
         * @return {Function} Debounced function
         */
        debounce: (func, wait) => {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }
      };
      
      // EVENT HANDLERS
      const handlers = {
        toggleTechniquePanel: (e) => {
          if (e) e.stopPropagation();
          const panel = state.elements.techniquePanel;
          // Close timer options if open
          state.elements.timerOptions.style.display = 'none';
          
          // Toggle technique panel
          const isVisible = panel.style.display === 'block';
          panel.style.display = isVisible ? 'none' : 'block';
          
          // Update ARIA
          utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', !isVisible);
        },
        
        selectTechnique: (btn) => {
          const selected = btn.getAttribute('data-technique');
          
          if (selected === 'learn-more') {
            handlers.showKnowledgeSection();
            return;
          }
          
          state.currentPattern = BREATHING_PATTERNS[selected];
          state.elements.techniqueButton.textContent = btn.textContent;
          resetBreathing();
          state.elements.techniquePanel.style.display = 'none';
          utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', false);
          
          // Show feedback toast
          utils.showToast(`Switched to ${btn.textContent} breathing`);
        },
        
        toggleFocusMode: () => {
          state.isFocusMode = !state.isFocusMode;
          document.body.classList.toggle('focus-mode', state.isFocusMode);
          state.elements.focusButton.textContent = state.isFocusMode ? 'EXIT FOCUS' : 'Focus';
          utils.setAriaState(state.elements.focusButton, 'aria-pressed', state.isFocusMode);
        },
        
        showKnowledgeSection: () => {
          state.elements.knowledgeSection.style.display = 'block';
          state.elements.knowledgeSection.setAttribute('aria-hidden', 'false');
          state.elements.techniquePanel.style.display = 'none';
          state.elements.timerOptions.style.display = 'none';
          
          // When showing knowledge section, pause the session timer
          if (state.sessionIntervalId) {
            clearInterval(state.sessionIntervalId);
            state.sessionIntervalId = null;
          }
        },
        
        hideKnowledgeSection: () => {
          state.elements.knowledgeSection.style.display = 'none';
          state.elements.knowledgeSection.setAttribute('aria-hidden', 'true');
          
          // When hiding knowledge section, resume the session timer
          startSessionTimer();
        },
        
        selectTechniqueInfo: (btn) => {
          // Remove active class from all buttons
          state.elements.techniqueBtns.forEach(b => {
            b.classList.remove('active');
            b.setAttribute('aria-selected', 'false');
          });
          
          // Add active class to clicked button
          btn.classList.add('active');
          btn.setAttribute('aria-selected', 'true');
          
          // Hide all technique info divs
          document.querySelectorAll('.technique-info').forEach(div => {
            div.classList.remove('active');
          });
          
          // Show the selected technique info
          const techniqueId = btn.getAttribute('data-technique');
          const targetInfo = document.getElementById(`${techniqueId}-info`);
          if (targetInfo) {
            targetInfo.classList.add('active');
          } else {
            console.error(`Info element not found for: ${techniqueId}`);
          }
        },
        
        toggleTimerOptions: (e) => {
          if (e) e.stopPropagation();
          const timerOptions = state.elements.timerOptions;
          
          // Close technique panel if open
          state.elements.techniquePanel.style.display = 'none';
          utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', false);
          
          // Toggle timer options
          timerOptions.style.display = (timerOptions.style.display === 'block') ? 'none' : 'block';
        },
        
        selectTimerOption: (btn) => {
          // Update active button
          document.querySelectorAll('.timer-options button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          // Set new duration
          const minutes = parseInt(btn.getAttribute('data-duration'));
          state.sessionDuration = minutes * 60;
          
          // Update the display immediately
          updateRemainingTimeDisplay();
          
          // Restart timer
          startSessionTimer();
          
          // Hide options
          state.elements.timerOptions.style.display = 'none';
          
          // Show feedback
          utils.showToast(`Session set to ${minutes} minutes`);
        },
        
        // Dismiss panels when clicking outside
        handleDocumentClick: (e) => {
          // Technique panel
          if (state.elements.techniquePanel.style.display === 'block' && 
              !state.elements.techniquePanel.contains(e.target) && 
              e.target !== state.elements.techniqueButton) {
            state.elements.techniquePanel.style.display = 'none';
            utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', false);
          }
          
          // Timer options
          if (state.elements.timerOptions.style.display === 'block' && 
              !state.elements.timerOptions.contains(e.target) && 
              e.target !== state.elements.progressBar) {
            state.elements.timerOptions.style.display = 'none';
          }
        },
        
        handleVisibilityChange: () => {
          state.isVisible = document.visibilityState !== 'hidden';
          
          // Apply battery-saving class when hidden
          document.body.classList.toggle('battery-saving', !state.isVisible);
          
          // When becoming visible again, check if animations need to be reset
          if (state.isVisible && state.animationFrameId === null) {
            // Restart animations
            startPhase(state.currentPhaseIndex);
          }
        },
        
        handleUserInteraction: () => {
          if (!state.hasInteracted) {
            state.hasInteracted = true;
            
            // Try to play all audio elements to satisfy user gesture requirement
            const audioElements = [
              state.elements.audioInhale,
              state.elements.audioHold,
              state.elements.audioExhale
            ];
            
            audioElements.forEach(audio => {
              if (audio) {
                const promise = audio.play();
                if (promise !== undefined) {
                  promise.then(() => {
                    audio.pause();
                    audio.currentTime = 0;
                  }).catch(e => {
                    // Still not allowed, will try again on next phase
                    console.log('Audio play blocked by browser policy:', e);
                  });
                }
              }
            });
          }
        }
      };
      
      // CORE FUNCTIONS
      function cacheElements() {
        // Cache DOM elements for performance
        state.elements = {
          appContainer: document.getElementById('appContainer'),
          loadingContainer: document.getElementById('loadingContainer'),
          loadingBar: document.getElementById('loadingBar'),
          breathingCircle: document.getElementById('breathingCircle'),
          techniqueButton: document.getElementById('techniqueButton'),
          focusButton: document.getElementById('focusButton'),
          techniquePanel: document.getElementById('techniquePanel'),
          knowledgeSection: document.getElementById('knowledgeSection'),
          backButton: document.getElementById('backButton'),
          techniqueBtns: document.querySelectorAll('.technique-btn'),
          timerDisplay: document.getElementById('timer'),
          progressBar: document.getElementById('progressBar'),
          progressIndicator: document.getElementById('progressIndicator'),
          timerOptions: document.getElementById('timerOptions'),
          remainingTime: document.getElementById('remainingTime'),
          audioInhale: document.getElementById('audioInhale'),
          audioHold: document.getElementById('audioHold'),
          audioExhale: document.getElementById('audioExhale'),
          toastContainer: document.getElementById('toastContainer'),
          buttonContainer: document.getElementById('buttonContainer'),
          installButton: document.getElementById('installButton'),
          holdProgress: document.getElementById('holdProgress'),
          holdProgressCircle: document.getElementById('holdProgressCircle')
        };
        
        state.loadedResources.dom = true;
        checkAllResourcesLoaded();
      }
      
      function initializeAudio() {
        // Set audio sources
        const audioElements = [
          { element: state.elements.audioInhale, src: AUDIO_SOURCES.inhale },
          { element: state.elements.audioHold, src: AUDIO_SOURCES.hold },
          { element: state.elements.audioExhale, src: AUDIO_SOURCES.exhale }
        ];
        
        // Calculate total loading steps
        const totalSteps = audioElements.length;
        let completedSteps = 0;
        
        // Update loading progress
        function updateLoadingProgress() {
          if (state.elements.loadingBar) {
            const progress = (completedSteps / totalSteps) * 100;
            state.elements.loadingBar.style.width = `${progress}%`;
          }
        }
        
        // Create a promise for each audio element
        const audioPromises = audioElements.map(({element, src}) => {
          return new Promise((resolve) => {
            if (!element) {
              completedSteps++;
              updateLoadingProgress();
              resolve();
              return;
            }
            
            element.src = src;
            
            // Handle successful loading
            element.addEventListener('canplaythrough', () => {
              completedSteps++;
              updateLoadingProgress();
              resolve();
            }, { once: true });
            
            // Handle errors but continue
            element.addEventListener('error', (e) => {
              console.warn(`Failed to load audio: ${src}`, e);
              completedSteps++;
              updateLoadingProgress();
              resolve(); // Resolve anyway to not block the app
            });
            
            // Handle timeout - don't wait forever
            setTimeout(() => {
              if (element.readyState < 4) {
                console.warn(`Audio load timeout: ${src}`);
                completedSteps++;
                updateLoadingProgress();
                resolve();
              }
            }, 5000);
          });
        });
        
        // Wait for all audio to load or timeout
        Promise.all(audioPromises)
          .then(() => {
            state.isAudioReady = true;
            state.loadedResources.audio = true;
            checkAllResourcesLoaded();
          })
          .catch(error => {
            console.error("Audio loading error:", error);
            // Continue anyway with potentially limited audio
            state.isAudioReady = false;
            state.loadedResources.audio = true; // Mark as "complete" even if failed
            checkAllResourcesLoaded();
          });
      }
      
      function checkAllResourcesLoaded() {
        // Check if all resources are loaded
        if (state.loadedResources.dom && state.loadedResources.audio) {
          // Small delay to ensure UI is ready
          setTimeout(() => {
            // Fade out loading screen
            state.elements.loadingContainer.style.opacity = '0';
            setTimeout(() => {
              state.elements.loadingContainer.style.display = 'none';
            }, 500);
            
            // Show app content with fade in
            state.elements.appContainer.style.opacity = '1';
            
            // Start the breathing animation
            startBreathing();
            
            // Start the session timer
            startSessionTimer();
            
            // Show iOS install instructions if appropriate
            showIOSInstallInstructions();
          }, 500);
        }
      }
      
      function showIOSInstallInstructions() {
        // Only show for iOS Safari
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        // Check if already installed as PWA
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                           window.navigator.standalone;
        
        if (isIOS && isSafari && !isStandalone) {
          // Check if we've shown the tip recently
          const lastDismissed = localStorage.getItem('ios-install-tip-dismissed');
          const dayInMs = 24 * 60 * 60 * 1000;
          
          // Only show once per day
          if (!lastDismissed || (Date.now() - parseInt(lastDismissed)) > dayInMs) {
            // Create installation tip
            const installTip = document.createElement('div');
            installTip.className = 'ios-install-tip';
            installTip.innerHTML = `
              <div class="tip-content">
                <p>Install this app on your iPhone: tap <strong>Share</strong> <span class="share-icon">â†‘</span> then <strong>Add to Home Screen</strong></p>
                <button class="close-tip">Ã—</button>
              </div>
            `;
            
            document.body.appendChild(installTip);
            
            // Handle close button
            installTip.querySelector('.close-tip').addEventListener('click', () => {
              installTip.style.display = 'none';
              
              // Store in localStorage to prevent showing again too soon
              localStorage.setItem('ios-install-tip-dismissed', Date.now());
            });
          }
        }
      }
      
      function attachEventListeners() {
        // First interaction for audio playback
        document.addEventListener('click', handlers.handleUserInteraction, { once: true });
        document.addEventListener('touchstart', handlers.handleUserInteraction, { once: true });
        
        // Technique Button Toggle
        state.elements.techniqueButton.addEventListener('click', handlers.toggleTechniquePanel);
        
        // Hide panels when clicking elsewhere
        document.addEventListener('click', handlers.handleDocumentClick);
        
        // Technique Selection
        const techniqueBtns = state.elements.techniquePanel.querySelectorAll('button');
        techniqueBtns.forEach(btn => {
          btn.addEventListener('click', () => handlers.selectTechnique(btn));
        });
        
        // Focus Mode Toggle
        state.elements.focusButton.addEventListener('click', handlers.toggleFocusMode);
        
        // Back Button in Knowledge Section
        state.elements.backButton.addEventListener('click', handlers.hideKnowledgeSection);
        
        // Knowledge Section Technique Navigation
        state.elements.techniqueBtns.forEach(btn => {
          btn.addEventListener('click', () => handlers.selectTechniqueInfo(btn));
        });
        
        // Progress Bar Click
        state.elements.progressBar.addEventListener('click', handlers.toggleTimerOptions);
        
        // Timer Options
        const timerOptionBtns = document.querySelectorAll('.timer-options button');
        timerOptionBtns.forEach(btn => {
          btn.addEventListener('click', () => handlers.selectTimerOption(btn));
        });
        
        // Tab visibility changes (for battery optimization)
        document.addEventListener('visibilitychange', handlers.handleVisibilityChange);
        
        // Window unload - clean up resources
        window.addEventListener('beforeunload', () => {
          // Cancel any pending animations or timers
          if (state.animationFrameId) {
            cancelAnimationFrame(state.animationFrameId);
          }
          if (state.sessionIntervalId) {
            clearInterval(state.sessionIntervalId);
          }
        });
        
        // Handle keyboard accessibility
        document.addEventListener('keydown', (e) => {
          // Escape key closes any open panels
          if (e.key === 'Escape') {
            if (state.elements.techniquePanel.style.display === 'block') {
              state.elements.techniquePanel.style.display = 'none';
              utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', false);
            }
            if (state.elements.timerOptions.style.display === 'block') {
              state.elements.timerOptions.style.display = 'none';
            }
            if (state.elements.knowledgeSection.style.display === 'block') {
              handlers.hideKnowledgeSection();
            }
          }
        });
        
        // Install button event
        if (state.elements.installButton) {
          state.elements.installButton.addEventListener('click', handleInstallClick);
        }
      }
      
      // BREATHING CONTROL FUNCTIONS
      function startBreathing() {
        state.currentPhaseIndex = 0;
        startPhase(state.currentPhaseIndex);
      }
      
      function resetBreathing() {
        // Cancel any existing animation frame
        if (state.animationFrameId) {
          cancelAnimationFrame(state.animationFrameId);
          state.animationFrameId = null;
        }
        
        state.currentScale = 1.0;
        startPhase(0);
      }
      
      function startPhase(phaseIndex) {
        const phase = state.currentPattern[phaseIndex];
        state.currentPhaseIndex = phaseIndex;
        
        // Set timestamps for this phase
        state.phaseStartTime = performance.now();
        state.phaseEndTime = state.phaseStartTime + (phase.duration * 1000);
        
        // Calculate phase duration in seconds
        state.phaseDuration = phase.duration;
        state.currentPhaseTime = phase.duration;
        
        playAudioCue(phase.label);
        applyPhaseAnimation(phase.label, phase.duration);
        
        // Manage hold progress indicator
        const isHoldPhase = phase.label.toLowerCase() === 'hold';
        if (isHoldPhase && state.elements.holdProgress) {
          // Reset and show the hold progress indicator
          const circle = state.elements.holdProgressCircle;
          const circumference = parseFloat(circle.getAttribute('stroke-dasharray'));
          
          // Initialize the hold progress - start with full circle
          circle.style.strokeDashoffset = '0';
          state.elements.holdProgress.style.opacity = '1';
        } else if (state.elements.holdProgress) {
          // Hide the hold progress for non-hold phases
          state.elements.holdProgress.style.opacity = '0';
        }
        
        // Add simple fade transition for text
        state.elements.timerDisplay.classList.add('fade');
        
        setTimeout(() => {
          // Set the appropriate label with cleaner logic
          let displayLabel = phase.label;
          displayLabel = displayLabel === 'Inhale2' ? 'Inhale' : 
                         (displayLabel.charAt(0).toUpperCase() + displayLabel.slice(1));
          
          state.elements.timerDisplay.textContent = displayLabel;
          state.elements.timerDisplay.classList.remove('fade');
        }, 150); // Short delay for fade transition
        
        // Cancel any existing animation frame
        if (state.animationFrameId) {
          cancelAnimationFrame(state.animationFrameId);
        }
        
        function updatePhase(timestamp) {
          // Calculate elapsed time since phase started
          const elapsed = timestamp - state.phaseStartTime;
          state.currentPhaseTime = Math.max(0, state.phaseDuration - (elapsed / 1000));
          
          // Update hold progress indicator if in hold phase
          if (isHoldPhase && state.elements.holdProgressCircle) {
            const circle = state.elements.holdProgressCircle;
            const circumference = parseFloat(circle.getAttribute('stroke-dasharray'));
            
            // Make sure progressRatio never exceeds 0.99 to prevent overflow
            const progressRatio = Math.min(0.99, elapsed / (phase.duration * 1000));
            
            // Apply the progress to the stroke-dashoffset
            const dashOffset = circumference * progressRatio;
            circle.style.strokeDashoffset = dashOffset.toString();
            
            // Hide the progress indicator when we're almost done
            if (progressRatio > 0.95) {
              state.elements.holdProgress.style.opacity = '0';
            }
          }
          
          // Check if phase is complete
          if (timestamp >= state.phaseEndTime) {
            const nextIndex = (state.currentPhaseIndex + 1) % state.currentPattern.length;
            startPhase(nextIndex);
            return;
          }
          
          // If document is hidden, don't request too many frames (battery saving)
          if (utils.shouldOptimizeBattery()) {
            // Request next frame with longer delay for battery saving
            state.animationFrameId = setTimeout(() => {
              requestAnimationFrame(updatePhase);
            }, 1000); // Update once per second when hidden
          } else {
            // Normal animation frame request
            state.animationFrameId = requestAnimationFrame(updatePhase);
          }
        }
        
        // Start the animation loop
        state.animationFrameId = requestAnimationFrame(updatePhase);
      }
      
      function applyPhaseAnimation(label, duration) {
        let nextScale = state.currentScale;
        switch (label.toLowerCase()) {
          case 'inhale': nextScale = 1.5; break;
          case 'inhale2': nextScale = 1.8; break; // Bigger scale for second inhale
          case 'exhale': nextScale = 0.6; break;
          case 'hold':   nextScale = state.currentScale; break;
          default:       nextScale = 1.0;
        }
        
        const circle = state.elements.breathingCircle;
        
        // Apply different transition speed based on battery optimization
        if (utils.shouldOptimizeBattery()) {
          circle.style.transition = `transform ${duration * 1.5}s linear`;
        } else {
          circle.style.transition = `transform ${duration}s cubic-bezier(0.4, 0.0, 0.2, 1)`;
        }
        
        circle.style.transform = `scale(${nextScale})`;
        state.currentScale = nextScale;
      }
      
      function playAudioCue(label) {
        // Skip if audio not initialized or user hasn't interacted
        if (!state.isAudioReady || !state.hasInteracted) return;
        
        try {
          let audioElement = null;
          
          if (label.toLowerCase() === 'inhale' || label.toLowerCase() === 'inhale2') {
            audioElement = state.elements.audioInhale;
          } else if (label.toLowerCase() === 'exhale') {
            audioElement = state.elements.audioExhale;
          } else if (label.toLowerCase() === 'hold') {
            audioElement = state.elements.audioHold;
          }
          
          if (audioElement) {
            audioElement.currentTime = 0;
            
            // Create a promise to handle play completion more robustly
            const playPromise = audioElement.play();
            
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                // Auto-play was prevented - common on mobile
                console.warn('Audio playback prevented:', error);
              });
            }
          }
          
          // Trigger haptic feedback
          triggerHapticFeedback(label.toLowerCase());
        } catch (e) {
          console.error('Audio play error:', e);
        }
      }
      
      function triggerHapticFeedback(phaseLabel) {
        // Skip if vibration is not supported or disabled
        if (!state.isVibrationSupported || !state.hapticEnabled) return;
        
        try {
          // Get the appropriate vibration pattern
          const pattern = HAPTIC_PATTERNS[phaseLabel] || [];
          
          if (pattern.length > 0) {
            // Some browsers return false if vibration fails
            const result = navigator.vibrate(pattern);
            if (result === false) {
              // Disable for this session if not working
              state.hapticEnabled = false;
              console.warn('Vibration failed - disabled');
            }
          }
        } catch (e) {
          console.warn('Haptic feedback error:', e);
          // Disable haptics if there's an error to prevent further errors
          state.hapticEnabled = false;
        }
      }
      
      // SESSION TIMER FUNCTIONS
      function startSessionTimer() {
        // Clear any existing interval
        if (state.sessionIntervalId) {
          clearInterval(state.sessionIntervalId);
        }
        
        // Set timestamp-based timer
        state.sessionStartTime = Date.now();
        state.sessionEndTime = state.sessionStartTime + (state.sessionDuration * 1000);
        state.sessionElapsed = 0;
        
        updateProgressBar();
        
        // Start new timer with 1 second updates
        state.sessionIntervalId = setInterval(() => {
          const now = Date.now();
          const elapsed = Math.floor((now - state.sessionStartTime) / 1000);
          state.sessionElapsed = elapsed;
          
          updateProgressBar();
          
          if (now >= state.sessionEndTime) {
            endSession();
          }
        }, 1000);
      }
      
      function updateProgressBar() {
        if (!state.elements.progressIndicator) return;
        
        const progressPercent = (state.sessionElapsed / state.sessionDuration) * 100;
        state.elements.progressIndicator.style.width = `${progressPercent}%`;
        
        // Update aria for accessibility
        state.elements.progressBar.setAttribute('aria-valuenow', progressPercent.toFixed(1));
        state.elements.progressBar.setAttribute('aria-valuemin', '0');
        state.elements.progressBar.setAttribute('aria-valuemax', '100');
        
        // Update remaining time display
        updateRemainingTimeDisplay();
      }
      
      function updateRemainingTimeDisplay() {
        if (!state.elements.remainingTime) return;
        
        const remainingSeconds = Math.max(0, state.sessionDuration - state.sessionElapsed);
        const formattedTime = utils.formatTime(remainingSeconds);
        state.elements.remainingTime.textContent = formattedTime;
        
        // Update ARIA label for screen readers
        state.elements.progressBar.setAttribute('aria-label', 
          `Session progress, ${formattedTime} remaining`);
      }
      
      function endSession() {
        clearInterval(state.sessionIntervalId);
        state.sessionIntervalId = null;
        
        // Reset progress bar with animation
        state.elements.progressIndicator.style.transition = 'width 0.5s ease-out';
        state.elements.progressIndicator.style.width = '100%';
        
        // Trigger haptic session completion pattern
        if (state.isVibrationSupported && state.hapticEnabled) {
          navigator.vibrate(HAPTIC_PATTERNS.sessionEnd);
        }
        
        // Show custom completion modal instead of alert
        showCompletionModal();
        
        // Call analytics session completion if enhanced features are enabled
        if (window.hagiusEnhanced && window.analytics) {
          window.analytics.endSession(true, 95);
        }
      }
      
      function showCompletionModal() {
        // Create modal element
        const modal = document.createElement('div');
        modal.className = 'completion-modal';
        modal.innerHTML = `
          <div class="modal-content">
            <h2>Session Complete!</h2>
            <p>Great job completing your breathing session.</p>
            <button id="closeModal">CONTINUE</button>
          </div>
        `;
        
        // Add to document
        document.body.appendChild(modal);
        
        // Force reflow to enable transition
        void modal.offsetWidth;
        modal.classList.add('visible');
        
        // Set up event handler
        document.getElementById('closeModal').addEventListener('click', () => {
          modal.classList.remove('visible');
          
          // Remove after transition completes
          setTimeout(() => {
            modal.remove();
            // Restart session timer
            startSessionTimer();
          }, 300);
        });
      }
      
      // PWA INSTALLATION FUNCTIONALITY
      let deferredPrompt;
      
      // Handle the beforeinstallprompt event
      window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent the default browser prompt
        e.preventDefault();
        // Store the event for later use
        deferredPrompt = e;
        // Show the install button
        if (state.elements.installButton) {
          state.elements.installButton.style.display = 'block';
        }
      });
      
      // Handle the install button click
      function handleInstallClick() {
        if (!deferredPrompt) return;
        
        // Show the install prompt
        deferredPrompt.prompt();
        
        // Wait for the user to respond
        deferredPrompt.userChoice.then((choiceResult) => {
          // Log the outcome
          console.log(`User response to install prompt: ${choiceResult.outcome}`);
          
          // Reset the deferred prompt variable
          deferredPrompt = null;
          
          // Hide the install button
          if (state.elements.installButton) {
            state.elements.installButton.style.display = 'none';
          }
          
          // If installed, show a toast
          if (choiceResult.outcome === 'accepted') {
            utils.showToast('App installed successfully!');
          }
        });
      }
      
      // Handle the appinstalled event
      window.addEventListener('appinstalled', (e) => {
        // Log the installation
        console.log('App was installed');
        
        // Hide the install button
        if (state.elements.installButton) {
          state.elements.installButton.style.display = 'none';
        }
        
        // Show a toast
        utils.showToast('App installed successfully!');
      });
      
      // ENHANCED FEATURES
      
      // DYNAMIC PARTICLE SYSTEM FOR BREATHING VISUALIZATION
      function initializeParticleSystem() {
        // Create canvas for particle animation
        const canvas = document.createElement('canvas');
        canvas.id = 'particleCanvas';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '1';
        document.body.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Particle class for breathing visualization
        class Particle {
          constructor(x, y, size, color, speedMultiplier = 1) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.color = color;
            this.baseSize = size;
            this.angle = Math.random() * Math.PI * 2;
            this.speedMultiplier = speedMultiplier;
            this.orbitRadius = 50 + Math.random() * 100;
            this.opacity = 0.1 + Math.random() * 0.5;
          }
          
          update(breatheIn, intensity) {
            // Move particles based on breathing state
            const direction = breatheIn ? 1 : -1;
            const speed = 0.02 * this.speedMultiplier * intensity;
            
            // Orbit around center with breathing influence
            this.angle += speed * direction;
            
            // Expand/contract orbit based on breathing
            const orbitChange = breatheIn ? 0.5 : -0.2;
            this.orbitRadius += orbitChange * intensity;
            this.orbitRadius = Math.max(10, Math.min(250, this.orbitRadius));
            
            // Particle size influenced by breathing
            this.size = this.baseSize * (1 + (direction * 0.1 * intensity));
            
            // Calculate position
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            this.x = centerX + Math.cos(this.angle) * this.orbitRadius;
            this.y = centerY + Math.sin(this.angle) * this.orbitRadius;
            
            // Adjust opacity based on breathing
            this.opacity = Math.min(0.8, this.opacity + (direction * 0.002 * intensity));
          }
          
          draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color.replace(')', `, ${this.opacity})`).replace('rgb', 'rgba');
            ctx.fill();
          }
        }
        
        // Create particle array
        const particles = [];
        const particleColors = [
          'rgb(255, 255, 255)',
          'rgb(200, 230, 255)',
          'rgb(180, 210, 255)'
        ];
        
        // Initialize particles
        for (let i = 0; i < 150; i++) {
          const x = canvas.width / 2;
          const y = canvas.height / 2;
          const size = 1 + Math.random() * 4;
          const color = particleColors[Math.floor(Math.random() * particleColors.length)];
          const speedMultiplier = 0.5 + Math.random() * 1.5;
          particles.push(new Particle(x, y, size, color, speedMultiplier));
        }
        
        // Animation variables
        let breatheIn = true;
        let breathingIntensity = 0;
        
        // Connect to breathing state
        function updateParticleBreathing(phase, progress) {
          // Map breathing phase to particle behavior
          switch(phase.toLowerCase()) {
            case 'inhale':
            case 'inhale2':
              breatheIn = true;
              breathingIntensity = progress;
              break;
            case 'exhale':
              breatheIn = false;
              breathingIntensity = progress;
              break;
            case 'hold':
              breatheIn = false;
              breathingIntensity = 0.3; // Subtle movement during hold
              break;
          }
        }
        
        // Animation loop
        function animateParticles() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Add radial gradient background
          const gradient = ctx.createRadialGradient(
            canvas.width/2, canvas.height/2, 10,
            canvas.width/2, canvas.height/2, 300
          );
          gradient.addColorStop(0, breatheIn ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.03)');
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.width);
          
          // Update and draw particles
          particles.forEach(particle => {
            particle.update(breatheIn, breathingIntensity);
            particle.draw();
          });
          
          requestAnimationFrame(animateParticles);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        });
        
        // Start animation
        animateParticles();
        
        // Return function to update breathing state
        return updateParticleBreathing;
      }
      
      // ADAPTIVE SOUNDSCAPES WITH BINAURAL BEATS
      function initializeSoundscapes() {
        // Create audio context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();
        
        // Audio nodes
        let binauralBeatNode = null;
        let leftOscillator = null;
        let rightOscillator = null;
        let gainNode = null;
        let ambientSound = null;
        
        // Available ambient soundscapes
        const soundscapes = {
          ocean: {
            url: 'sounds/ocean-waves.mp3',
            baseFreq: 136.1, // 136.1 Hz "OM" frequency
            binauralBeatDiff: 6 // 6 Hz - Promotes deep relaxation
          },
          forest: {
            url: 'sounds/forest-ambience.mp3',
            baseFreq: 174, // 174 Hz - Reduces pain and stress
            binauralBeatDiff: 4.5 // 4.5 Hz - Increases intuition and creativity
          },
          night: {
            url: 'sounds/night-sounds.mp3',
            baseFreq: 285, // 285 Hz - Healing and tissue regeneration
            binauralBeatDiff: 3 // 3 Hz - Deep relaxation
          },
          rain: {
            url: 'sounds/gentle-rain.mp3',
            baseFreq: 396, // 396 Hz - Liberating fear
            binauralBeatDiff: 7.83 // 7.83 Hz - Earth's Schumann Resonance
          }
        };
        
        // Current soundscape
        let currentSoundscape = 'ocean';
        
        // Generate binaural beats
        function createBinauralBeats(baseFrequency, beatFrequency) {
          // Stop existing beats if any
          if (leftOscillator) {
            leftOscillator.stop();
            rightOscillator.stop();
          }
          
          // Create stereo panner for separate ear channels
          const leftPanner = audioContext.createStereoPanner();
          leftPanner.pan.value = -1;  // Hard left
          
          const rightPanner = audioContext.createStereoPanner();
          rightPanner.pan.value = 1;  // Hard right
          
          // Create gain node for volume control
          gainNode = audioContext.createGain();
          gainNode.gain.value = 0.15; // Low volume for background
          
          // Create oscillators
          leftOscillator = audioContext.createOscillator();
          leftOscillator.type = 'sine';
          leftOscillator.frequency.value = baseFrequency;
          
          rightOscillator = audioContext.createOscillator();
          rightOscillator.type = 'sine';
          rightOscillator.frequency.value = baseFrequency + beatFrequency;
          
          // Connect nodes
          leftOscillator.connect(leftPanner);
          rightOscillator.connect(rightPanner);
          leftPanner.connect(gainNode);
          rightPanner.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Start oscillators
          leftOscillator.start();
          rightOscillator.start();
        }
        
        // Load and play ambient sound
        async function loadAmbientSound(soundscapeKey) {
          try {
            const soundscape = soundscapes[soundscapeKey];
            const response = await fetch(soundscape.url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            if (ambientSound) {
              ambientSound.stop();
            }
            
            ambientSound = audioContext.createBufferSource();
            ambientSound.buffer = audioBuffer;
            ambientSound.loop = true;
            
            const ambientGain = audioContext.createGain();
            ambientGain.gain.value = 0.3;
            
            ambientSound.connect(ambientGain);
            ambientGain.connect(audioContext.destination);
            ambientSound.start();
            
            // Create matching binaural beats
            createBinauralBeats(soundscape.baseFreq, soundscape.binauralBeatDiff);
            
            return true;
          } catch (error) {
            console.error('Error loading ambient sound:', error);
            return false;
          }
        }
        
        // Adapt based on breathing technique
        function adaptSoundToTechnique(technique) {
          let recommendedSoundscape;
          
          switch(technique) {
            case 'resonance':
              recommendedSoundscape = 'ocean';
              break;
            case 'box':
              recommendedSoundscape = 'forest';
              break;
            case '478':
              recommendedSoundscape = 'night';
              break;
            case 'physio-sigh':
              recommendedSoundscape = 'rain';
              break;
            default:
              recommendedSoundscape = 'ocean';
          }
          
          if (recommendedSoundscape !== currentSoundscape) {
            currentSoundscape = recommendedSoundscape;
            loadAmbientSound(currentSoundscape);
          }
        }
        
        // Adjust sound based on breathing phase
        function adjustSoundToBreathing(phase, progress) {
          if (!gainNode) return;
          
          // Subtle volume changes based on breathing phase
          switch(phase.toLowerCase()) {
            case 'inhale':
            case 'inhale2':
              // Gradually increase volume during inhale
              gainNode.gain.linearRampToValueAtTime(
                0.25, // Target volume
                audioContext.currentTime + 0.2 // Ramp time
              );
              break;
            case 'exhale':
              // Gradually decrease volume during exhale
              gainNode.gain.linearRampToValueAtTime(
                0.15, // Target volume
                audioContext.currentTime + 0.2 // Ramp time
              );
              break;
            case 'hold':
              // Maintain steady volume during hold
              gainNode.gain.linearRampToValueAtTime(
                0.2, // Target volume
                audioContext.currentTime + 0.1 // Ramp time
              );
              break;
          }
        }
        
        // Public interface
        return {
          start: () => {
            // Resume audio context if suspended (autoplay policy)
            if (audioContext.state === 'suspended') {
              audioContext.resume();
            }
            loadAmbientSound(currentSoundscape);
          },
          stop: () => {
            if (leftOscillator) {
              leftOscillator.stop();
              rightOscillator.stop();
            }
            if (ambientSound) {
              ambientSound.stop();
            }
          },
          adaptToTechnique: adaptSoundToTechnique,
          updateWithBreathing: adjustSoundToBreathing,
          setSoundscapeVolume: (volume) => {
            if (gainNode) {
              gainNode.gain.value = volume;
            }
          }
        };
      }
      
      // ADVANCED HAPTIC PATTERNS BASED ON BREATHING PHASES
      function initializeAdvancedHaptics() {
        // Check if vibration API is supported
        const isSupported = 'vibrate' in navigator;
        
        // Enhanced haptic patterns (milliseconds)
        const hapticPatterns = {
          // Inhale: subtle build-up pattern
          inhale: [10, 10, 15, 10, 20, 10, 25, 10, 30],
          
          // Hold: uniform gentle pulses
          hold: [5, 20, 5, 20, 5],
          
          // Exhale: gradual fade-out pattern
          exhale: [30, 10, 25, 10, 20, 10, 15, 10, 10],
          
          // Second inhale for physio-sigh: short intense
          inhale2: [40, 10, 60],
          
          // Session completion: celebratory pattern
          sessionEnd: [50, 50, 50, 50, 100, 50, 150]
        };
        
        // Dynamically adjust haptic intensity based on session progress
        function getAdjustedPattern(pattern, sessionProgress) {
          // Calculate intensity factor (increases as session progresses)
          // This creates a gentle build up of haptic intensity throughout the session
          const intensityFactor = 0.8 + (sessionProgress * 0.4); // 0.8-1.2 range
          
          // Apply intensity factor to each pattern duration
          return pattern.map(duration => Math.round(duration * intensityFactor));
        }
        
        // Trigger haptic feedback
        function triggerHaptic(phase, sessionProgress = 0) {
          if (!isSupported) return false;
          
          try {
            const basePattern = hapticPatterns[phase.toLowerCase()];
            if (!basePattern) return false;
            
            // Get intensity-adjusted pattern
            const pattern = getAdjustedPattern(basePattern, sessionProgress);
            
            // Trigger vibration
            const result = navigator.vibrate(pattern);
            return result;
          } catch (error) {
            console.warn('Haptic error:', error);
            return false;
          }
        }
        
        return {
          isSupported,
          triggerForPhase: triggerHaptic,
          sessionComplete: () => {
            if (isSupported) {
              navigator.vibrate(hapticPatterns.sessionEnd);
            }
          }
        };
      }
      
      // BREATHING ANALYTICS AND INSIGHTS DASHBOARD
      function initializeBreathingAnalytics() {
        // Local storage key
        const STORAGE_KEY = 'hagius_breathing_analytics';
        
        // Session data structure
        class SessionData {
          constructor(technique, duration) {
            this.id = Date.now();
            this.date = new Date().toISOString();
            this.technique = technique;
            this.duration = duration; // in seconds
            this.completed = false;
            this.consistency = 0; // 0-100 score
            this.mood = null; // pre-session mood
            this.moodAfter = null; // post-session mood
          }
        }
        
        // Load existing data
        function loadAnalyticsData() {
          try {
            const data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : { sessions: [] };
          } catch (error) {
            console.error('Error loading analytics data:', error);
            return { sessions: [] };
          }
        }
        
        // Save data
        function saveAnalyticsData(data) {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            return true;
          } catch (error) {
            console.error('Error saving analytics data:', error);
            return false;
          }
        }
        
        // Current session
        let currentSession = null;
        
        // Start tracking a new session
        function startSession(technique, duration) {
          currentSession = new SessionData(technique, duration);
          
          // Update data store
          const data = loadAnalyticsData();
          data.sessions.push(currentSession);
          saveAnalyticsData(data);
          
          return currentSession.id;
        }
        
        // End current session
        function endSession(completed = true, consistency = 95) {
          if (!currentSession) return false;
          
          // Update session data
          currentSession.completed = completed;
          currentSession.consistency = consistency;
          currentSession.endTime = Date.now();
          
          // Update in storage
          const data = loadAnalyticsData();
          const index = data.sessions.findIndex(s => s.id === currentSession.id);
          if (index !== -1) {
            data.sessions[index] = currentSession;
            saveAnalyticsData(data);
          }
          
          // Ask for mood after session
          promptForMood('after');
          
          return true;
        }
        
        // Prompt user for mood
        function promptForMood(stage = 'before') {
          if (!currentSession) return;
          
          // Create mood selection modal
          const modal = document.createElement('div');
          modal.className = 'mood-modal';
          modal.innerHTML = `
            <div class="mood-content">
              <h2>How do you feel ${stage === 'before' ? 'right now' : 'after this session'}?</h2>
              <div class="mood-options">
                <button data-mood="calm" class="mood-button">ðŸ˜Œ Calm</button>
                <button data-mood="stressed" class="mood-button">ðŸ˜° Stressed</button>
                <button data-mood="tired" class="mood-button">ðŸ˜´ Tired</button>
                <button data-mood="focused" class="mood-button">ðŸ§  Focused</button>
                <button data-mood="anxious" class="mood-button">ðŸ˜Ÿ Anxious</button>
                <button data-mood="energized" class="mood-button">âš¡ Energized</button>
              </div>
            </div>
          `;
          
          document.body.appendChild(modal);
          
          // Add event listeners
          const buttons = modal.querySelectorAll('.mood-button');
          buttons.forEach(button => {
            button.addEventListener('click', () => {
              const mood = button.getAttribute('data-mood');
              
              // Update session data
              if (stage === 'before') {
                currentSession.mood = mood;
              } else {
                currentSession.moodAfter = mood;
              }
              
              // Update in storage
              const data = loadAnalyticsData();
              const index = data.sessions.findIndex(s => s.id === currentSession.id);
              if (index !== -1) {
                data.sessions[index] = currentSession;
                saveAnalyticsData(data);
              }
              
              // Remove modal
              modal.remove();
            });
          });
        }
        
        // Generate personalized insights
        function generateInsights(data) {
          const insights = [];
          const sessions = data.sessions;
          
          if (sessions.length === 0) {
            return ["Welcome to your breathing journey! Complete your first session to see insights."];
          }
          
          // Most used technique
          const techniqueCounts = {};
          sessions.forEach(s => {
            techniqueCounts[s.technique] = (techniqueCounts[s.technique] || 0) + 1;
          });
          
          const mostUsedTechnique = Object.entries(techniqueCounts)
            .sort((a, b) => b[1] - a[1])[0][0];
          
          insights.push(`Your preferred technique is ${mostUsedTechnique} breathing.`);
          
          // Consistency pattern
          const recentCompletionRate = sessions
            .slice(-5)
            .filter(s => s.completed)
            .length / Math.min(sessions.length, 5);
          
          if (recentCompletionRate >= 0.8) {
            insights.push("You've been very consistent recently. Great work!");
          } else if (recentCompletionRate <= 0.4 && sessions.length > 3) {
            insights.push("Try shorter sessions to build consistency.");
          }
          
          // Mood improvement patterns
          const moodChanges = sessions
            .filter(s => s.mood && s.moodAfter)
            .map(s => ({before: s.mood, after: s.moodAfter}));
          
          const stressReduction = moodChanges
            .filter(m => m.before === 'stressed' && (m.after === 'calm' || m.after === 'focused'))
            .length;
          
          if (stressReduction >= 2) {
            insights.push("Breathing has been effective at reducing your stress levels.");
          }
          
          // Time of day pattern
          const sessionTimes = sessions.map(s => new Date(s.date).getHours());
          const morningCount = sessionTimes.filter(h => h >= 5 && h < 12).length;
          const eveningCount = sessionTimes.filter(h => h >= 18 && h < 24).length;
          
          if (morningCount > eveningCount && morningCount > sessions.length * 0.6) {
            insights.push("You prefer morning sessions, which can help set a calm tone for your day.");
          } else if (eveningCount > morningCount && eveningCount > sessions.length * 0.6) {
            insights.push("You prefer evening sessions, which can help you unwind and prepare for rest.");
          }
          
          // Add recommendation if we have fewer than 3 insights
          if (insights.length < 3) {
            insights.push("Try the resonance breathing technique for enhanced heart rate variability benefits.");
          }
          
          return insights;
        }
        
        // Generate visual analytics dashboard
        function createAnalyticsDashboard() {
          const data = loadAnalyticsData();
          
          // Get stats
          const totalSessions = data.sessions.length;
          const completedSessions = data.sessions.filter(s => s.completed).length;
          const totalMinutes = Math.round(data.sessions.reduce((acc, s) => acc + s.duration, 0) / 60);
          
          // Aggregate by technique
          const techniqueStats = {};
          data.sessions.forEach(session => {
            if (!techniqueStats[session.technique]) {
              techniqueStats[session.technique] = 0;
            }
            techniqueStats[session.technique]++;
          });
          
          // Create dashboard HTML
          const dashboard = document.createElement('div');
          dashboard.className = 'analytics-dashboard';
          dashboard.innerHTML = `
            <div class="dashboard-header">
              <h2>Your Breathing Journey</h2>
              <button class="close-dashboard">Ã—</button>
            </div>
            
            <div class="dashboard-stats">
              <div class="stat-card">
                <div class="stat-number">${totalSessions}</div>
                <div class="stat-label">Sessions</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${totalMinutes}</div>
                <div class="stat-label">Minutes</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${Math.round((completedSessions/totalSessions || 0) * 100)}%</div>
                <div class="stat-label">Completion</div>
              </div>
            </div>
            
            <div class="dashboard-chart">
              <h3>Your Technique Preferences</h3>
              <div class="technique-bars">
                ${Object.entries(techniqueStats).map(([technique, count]) => `
                  <div class="technique-stat">
                    <div class="technique-name">${technique}</div>
                    <div class="technique-bar-container">
                      <div class="technique-bar" style="width: ${(count/totalSessions)*100}%"></div>
                      <span class="technique-count">${count}</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            
            <div class="dashboard-insights">
              <h3>Insights</h3>
              <ul class="insights-list">
                ${generateInsights(data).map(insight => `
                  <li class="insight-item">${insight}</li>
                `).join('')}
              </ul>
            </div>
          `;
          
          // Add to DOM
          document.body.appendChild(dashboard);
          
          // Close button handler
          dashboard.querySelector('.close-dashboard').addEventListener('click', () => {
            dashboard.remove();
          });
          
          return dashboard;
        }
        
        // Return public interface
        return {
          startSession,
          endSession,
          promptForMood,
          showDashboard: createAnalyticsDashboard
        };
      }
      
      // DYNAMIC COLOR THERAPY
      function initializeColorTherapy() {
        // Color themes mapped to effects/moods
        const colorThemes = {
          calm: {
            primary: '#3a7ca5',
            secondary: '#63c5da',
            gradient: 'linear-gradient(to bottom, #3a7ca5, #63c5da)'
          },
          focus: {
            primary: '#7953a9',
            secondary: '#a893cc',
            gradient: 'linear-gradient(to bottom, #7953a9, #a893cc)'
          },
          energize: {
            primary: '#da6c42',
            secondary: '#f3c677',
            gradient: 'linear-gradient(to bottom, #da6c42, #f3c677)'
          },
          sleep: {
            primary: '#2d4262',
            secondary: '#6e7e9f',
            gradient: 'linear-gradient(to bottom, #2d4262, #6e7e9f)'
          },
          balance: {
            primary: '#2a7e19',
            secondary: '#7ca35f',
            gradient: 'linear-gradient(to bottom, #2a7e19, #7ca35f)'
          }
        };
        
        // Current theme
        let currentTheme = 'calm';
        
        // Change theme with smooth transition
        function changeTheme(themeName) {
          if (!colorThemes[themeName]) return false;
          
          const theme = colorThemes[themeName];
          const root = document.documentElement;
          
          // Create transition style
          const transitionStyle = document.createElement('style');
          transitionStyle.textContent = `
            body {
              transition: background 1.5s ease-in-out;
            }
            .breathing-circle {
              transition: box-shadow 1.5s ease-in-out, transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
            }
          `;
          document.head.appendChild(transitionStyle);
          
          // Apply new theme
          document.body.style.background = theme.gradient;
          root.style.setProperty('--primary-color', theme.primary);
          root.style.setProperty('--secondary-color', theme.secondary);
          
          // Update breathing circle glow
          const breathingCircle = document.querySelector('.breathing-circle');
          if (breathingCircle) {
            breathingCircle.style.boxShadow = `0 0 30px ${theme.primary}50, 0 0 60px ${theme.secondary}30`;
          }
          
          // Remove transition style after animation completes
          setTimeout(() => {
            transitionStyle.remove();
          }, 1500);
          
          currentTheme = themeName;
          return true;
        }
        
        // Recommend theme based on time of day
        function getTimeBasedTheme() {
          const hour = new Date().getHours();
          
          if (hour >= 5 && hour < 9) {
            return 'energize'; // Morning energize
          } else if (hour >= 9 && hour < 15) {
            return 'focus';    // Daytime focus
          } else if (hour >= 15 && hour < 20) {
            return 'balance';  // Evening balance
          } else {
            return 'sleep';    // Night sleep
          }
        }
        
        // Match theme to breathing technique
        function getThemeForTechnique(technique) {
          switch(technique) {
            case 'resonance': return 'calm';
            case 'box': return 'focus';
            case '478': return 'sleep';
            case 'physio-sigh': return 'energize';
            default: return 'calm';
          }
        }
        
        // Subtle color pulse with breathing
        function pulseWithBreathing(phase, progress) {
          const breathingCircle = document.querySelector('.breathing-circle');
          if (!breathingCircle) return;
          
          const theme = colorThemes[currentTheme];
          
          switch(phase.toLowerCase()) {
            case 'inhale':
            case 'inhale2':
              // Brighten during inhale
              breathingCircle.style.boxShadow = `0 0 30px ${theme.primary}80, 0 0 60px ${theme.secondary}50`;
              break;
            case 'exhale':
              // Dim during exhale
              breathingCircle.style.boxShadow = `0 0 20px ${theme.primary}40, 0 0 40px ${theme.secondary}20`;
              break;
            case 'hold':
              // Stable during hold
              breathingCircle.style.boxShadow = `0 0 25px ${theme.primary}60, 0 0 50px ${theme.secondary}30`;
              break;
          }
        }
        
        // Expose public interface
        return {
          setTheme: changeTheme,
          getTimeBasedTheme,
          getThemeForTechnique,
          pulseWithBreathing
        };
      }
      
      // VOICE GUIDANCE SYSTEM
      function initializeVoiceGuidance() {
        // Create speech synthesis interface
        const synth = window.speechSynthesis;
        let speaking = false;
        let voiceOptions = [];
        let selectedVoice = null;
        let volume = 0.8;
        let enabled = false;
        
        // Initialize available voices
        function loadVoices() {
          return new Promise((resolve) => {
            const voices = synth.getVoices();
            
            if (voices.length > 0) {
              voiceOptions = voices;
              // Select a default voice - prioritize natural-sounding ones
              selectedVoice = voices.find(v => 
                v.name.includes('Female') || 
                v.name.includes('Samantha') || 
                v.name.includes('Google')
              ) || voices[0];
              
              resolve(true);
            } else {
              // Wait for voices to load
              window.speechSynthesis.onvoiceschanged = () => {
                voiceOptions = synth.getVoices();
                selectedVoice = voiceOptions.find(v => 
                  v.name.includes('Female') || 
                  v.name.includes('Samantha') || 
                  v.name.includes('Google')
                ) || voiceOptions[0];
                
                resolve(true);
              };
            }
          });
        }
        
        // Speak guidance text
        function speak(text, priority = false) {
          if (!enabled || !selectedVoice) return false;
          
          // Cancel current speech if priority
          if (speaking && priority) {
            synth.cancel();
          } else if (speaking) {
            return false;
          }
          
          // Create utterance
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.voice = selectedVoice;
          utterance.volume = volume;
          utterance.rate = 0.9; // Slightly slower for calming effect
          utterance.pitch = 1;
          
          // Set speaking state
          speaking = true;
          
          // Track completion
          utterance.onend = () => {
            speaking = false;
          };
          
          // Speak
          synth.speak(utterance);
          return true;
        }
        
        // Get appropriate guidance for phase
        function getPhaseGuidance(phase, technique) {
          // Vary instructions based on technique and phase
          switch(technique) {
            case 'resonance':
              if (phase.toLowerCase() === 'inhale') {
                return "Breathe in slowly through your nose";
              } else if (phase.toLowerCase() === 'exhale') {
                return "Now exhale gently, letting go of tension";
              }
              break;
              
            case 'box':
              if (phase.toLowerCase() === 'inhale') {
                return "Inhale deeply through your nose";
              } else if (phase.toLowerCase() === 'hold') {
                return "Hold your breath gently";
              } else if (phase.toLowerCase() === 'exhale') {
                return "Exhale completely";
              }
              break;
              
            case '478':
              if (phase.toLowerCase() === 'inhale') {
                return "Inhale quietly through your nose";
              } else if (phase.toLowerCase() === 'hold') {
                return "Hold your breath";
              } else if (phase.toLowerCase() === 'exhale') {
                return "Exhale completely through your mouth";
              }
              break;
              
            case 'physio-sigh':
              if (phase.toLowerCase() === 'inhale') {
                return "Take your first inhale";
              } else if (phase.toLowerCase() === 'inhale2') {
                return "Second inhale, fill your lungs";
              } else if (phase.toLowerCase() === 'exhale') {
                return "Long exhale, release fully";
              }
              break;
              
            default:
              if (phase.toLowerCase() === 'inhale') {
                return "Breathe in";
              } else if (phase.toLowerCase() === 'hold') {
                return "Hold";
              } else if (phase.toLowerCase() === 'exhale') {
                return "Breathe out";
              }
          }
          
          return "";
        }
        
        // Create voice guidance settings UI
        function createSettingsUI() {
          const modal = document.createElement('div');
          modal.className = 'voice-settings-modal';
          modal.innerHTML = `
            <div class="voice-settings-content">
              <h2>Voice Guidance Settings</h2>
              
              <div class="setting-group">
                <label class="setting-label">
                  <span>Enable Voice Guidance</span>
                  <label class="toggle">
                    <input type="checkbox" id="voice-enabled" ${enabled ? 'checked' : ''}>
                    <span class="toggle-slider"></span>
                  </label>
                </label>
              </div>
              
              <div class="setting-group">
                <label for="voice-select" class="setting-label">Voice</label>
                <select id="voice-select" ${!enabled ? 'disabled' : ''}>
                  ${voiceOptions.map(voice => `
                    <option value="${voice.name}" ${voice === selectedVoice ? 'selected' : ''}>
                      ${voice.name}
                    </option>
                  `).join('')}
                </select>
              </div>
              
              <div class="setting-group">
                <label for="voice-volume" class="setting-label">Volume</label>
                <input type="range" id="voice-volume" min="0" max="1" step="0.1" value="${volume}" ${!enabled ? 'disabled' : ''}>
                <span id="volume-value">${Math.round(volume * 100)}%</span>
              </div>
              
              <div class="setting-group">
                <button id="test-voice" class="test-voice-btn" ${!enabled ? 'disabled' : ''}>Test Voice</button>
              </div>
              
              <div class="settings-buttons">
                <button id="save-voice-settings">Save</button>
                <button id="cancel-voice-settings">Cancel</button>
              </div>
            </div>
          `;
          
          document.body.appendChild(modal);
          
          // Set up event handlers
          const enableToggle = document.getElementById('voice-enabled');
          const voiceSelect = document.getElementById('voice-select');
          const volumeSlider = document.getElementById('voice-volume');
          const volumeValue = document.getElementById('volume-value');
          const testButton = document.getElementById('test-voice');
          const saveButton = document.getElementById('save-voice-settings');
          const cancelButton = document.getElementById('cancel-voice-settings');
          
          // Enable/disable controls
          enableToggle.addEventListener('change', () => {
            const isEnabled = enableToggle.checked;
            voiceSelect.disabled = !isEnabled;
            volumeSlider.disabled = !isEnabled;
            testButton.disabled = !isEnabled;
          });
          
          // Update volume display
          volumeSlider.addEventListener('input', () => {
            volumeValue.textContent = `${Math.round(volumeSlider.value * 100)}%`;
          });
          
          // Test voice
          testButton.addEventListener('click', () => {
            const testVoice = voiceOptions.find(v => v.name === voiceSelect.value);
            if (testVoice) {
              const tempSelected = selectedVoice;
              const tempVolume = volume;
              
              selectedVoice = testVoice;
              volume = parseFloat(volumeSlider.value);
              
              speak("This is how your voice guidance will sound.", true);
              
              // Restore settings
              selectedVoice = tempSelected;
              volume = tempVolume;
            }
          });
          
          // Save settings
          saveButton.addEventListener('click', () => {
            enabled = enableToggle.checked;
            volume = parseFloat(volumeSlider.value);
            selectedVoice = voiceOptions.find(v => v.name === voiceSelect.value) || selectedVoice;
            
            modal.remove();
          });
          
          // Cancel
          cancelButton.addEventListener('click', () => {
            modal.remove();
          });
        }
        
        // Initialize and return public interface
        return loadVoices().then(() => {
          return {
            speakPhaseGuidance: (phase, technique) => {
              const guidance = getPhaseGuidance(phase, technique);
              return speak(guidance);
            },
            speakMessage: (message, priority = false) => {
              return speak(message, priority);
            },
            isEnabled: () => enabled,
            setEnabled: (value) => {
              enabled = !!value;
              return enabled;
            },
            showSettings: createSettingsUI
          };
        });
      }
      
      // ADD ENHANCED UI ELEMENTS
      
      function addThemeSelector() {
        // Add theme button to top navigation
        const headerElement = document.querySelector('.header');
        if (!headerElement) return;
        
        const themeButton = document.createElement('button');
        themeButton.id = 'themeButton';
        themeButton.className = 'theme-button';
        themeButton.innerText = 'ðŸŽ¨';
        themeButton.title = 'Change color theme';
        
        headerElement.appendChild(themeButton);
        
        // Create theme selector panel
        const themeSelector = document.createElement('div');
        themeSelector.className = 'theme-selector';
        themeSelector.innerHTML = `
          <div class="theme-option" data-theme="calm" style="background: linear-gradient(to bottom, #3a7ca5, #63c5da)"></div>
          <div class="theme-option" data-theme="focus" style="background: linear-gradient(to bottom, #7953a9, #a893cc)"></div>
          <div class="theme-option" data-theme="energize" style="background: linear-gradient(to bottom, #da6c42, #f3c677)"></div>
          <div class="theme-option" data-theme="sleep" style="background: linear-gradient(to bottom, #2d4262, #6e7e9f)"></div>
          <div class="theme-option" data-theme="balance" style="background: linear-gradient(to bottom, #2a7e19, #7ca35f)"></div>
        `;
        
        headerElement.appendChild(themeSelector);
        
        // Toggle theme selector
        themeButton.addEventListener('click', () => {
          const isVisible = themeSelector.style.display === 'block';
          themeSelector.style.display = isVisible ? 'none' : 'block';
        });
        
        // Close when clicking outside
        document.addEventListener('click', (e) => {
          if (e.target !== themeButton && !themeSelector.contains(e.target)) {
            themeSelector.style.display = 'none';
          }
        });
        
        // Theme option selection
        const themeOptions = themeSelector.querySelectorAll('.theme-option');
        themeOptions.forEach(option => {
          option.addEventListener('click', () => {
            const themeName = option.getAttribute('data-theme');
            
            // Update active class
            themeOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            
            // Apply theme
            if (window.colorTherapy) {
              window.colorTherapy.setTheme(themeName);
            }
            
            // Hide selector
            themeSelector.style.display = 'none';
          });
        });
      }
      
      function addVoiceSettingsButton() {
        const buttonContainer = document.getElementById('buttonContainer');
        if (!buttonContainer) return;
        
        const voiceButton = document.createElement('button');
        voiceButton.id = 'voiceSettingsButton';
        voiceButton.className = 'bottom-button';
        voiceButton.innerText = 'VOICE';
        
        // Add as last button
        buttonContainer.appendChild(voiceButton);
        
        // Add event listener
        voiceButton.addEventListener('click', () => {
          if (window.voiceGuidance) {
            window.voiceGuidance.showSettings();
          }
        });
      }
      
      function addAnalyticsButton() {
        const buttonContainer = document.getElementById('buttonContainer');
        if (!buttonContainer) return;
        
        const analyticsButton = document.createElement('button');
        analyticsButton.id = 'analyticsButton';
        analyticsButton.className = 'bottom-button';
        analyticsButton.innerText = 'STATS';
        
        // Insert before install button if it exists
        const installButton = document.getElementById('installButton');
        if (installButton) {
          buttonContainer.insertBefore(analyticsButton, installButton);
        } else {
          buttonContainer.appendChild(analyticsButton);
        }
        
        // Add event listener
        analyticsButton.addEventListener('click', () => {
          if (window.analytics) {
            window.analytics.showDashboard();
          }
        });
      }
      
      // MAIN ENHANCEMENT FUNCTION
      function enhanceBreathingApp() {
        // State for enhancements
        let particleSystem = null;
        let soundscapes = null;
        let haptics = null;
        let analytics = null;
        let colorTherapy = null;
        let voiceGuidance = null;
        
        // Only initialize once
        if (window.hagiusEnhanced) return;
        window.hagiusEnhanced = true;
        
        // Initialize core enhancements
        particleSystem = initializeParticleSystem();
        soundscapes = initializeSoundscapes();
        haptics = initializeAdvancedHaptics();
        analytics = initializeBreathingAnalytics();
        colorTherapy = initializeColorTherapy();
        
        // Store in window for access
        window.particleSystem = particleSystem;
        window.soundscapes = soundscapes;
        window.haptics = haptics;
        window.analytics = analytics;
        window.colorTherapy = colorTherapy;
        
        // Initialize voice guidance (async)
        initializeVoiceGuidance().then(guidance => {
          voiceGuidance = guidance;
          window.voiceGuidance = voiceGuidance;
          
          // Add voice settings button to app
          addVoiceSettingsButton();
        });
        
        // Add stats/dashboard button
        addAnalyticsButton();
        
        // Add theme selector
        addThemeSelector();
        
        // Connect to breathing phases
        connectToBreathingPhases();
        
        // Connect to technique selection
        connectToTechniqueSelection();
        
        // Connect to session lifecycle
        connectToSessionLifecycle();
        
        // Add subtle animations to UI elements
        enhanceUIElements();
        
        // Apply time-based color theme
        if (colorTherapy) {
          const theme = colorTherapy.getTimeBasedTheme();
          colorTherapy.setTheme(theme);
        }
        
        // Start ambient sound with binaural beats after a small delay
        if (soundscapes) {
          setTimeout(() => {
            soundscapes.start();
          }, 2000);
        }
      }
      
      // Connect to breathing phases
      function connectToBreathingPhases() {
        // Monitor phase changes by overriding startPhase function
        const originalStartPhase = window.startPhase;
        if (!originalStartPhase) {
          console.error('Could not find startPhase function to enhance');
          return;
        }
        
        window.startPhase = function(phaseIndex) {
          // Call original function first
          originalStartPhase(phaseIndex);
          
          // Now enhance with our features
          const phase = state.currentPattern[phaseIndex];
          const progress = 0.5; // Default progress value 
          const technique = findCurrentTechniqueName();
          
          // Update particle system
          if (window.particleSystem) {
            window.particleSystem(phase.label, progress);
          }
          
          // Update soundscapes
          if (window.soundscapes) {
            window.soundscapes.updateWithBreathing(phase.label, progress);
          }
          
          // Trigger haptic feedback
          if (window.haptics) {
            window.haptics.triggerForPhase(phase.label, window.state.sessionElapsed / window.state.sessionDuration);
          }
          
          // Update color therapy
          if (window.colorTherapy) {
            window.colorTherapy.pulseWithBreathing(phase.label, progress);
          }
          
          // Speak guidance
          if (window.voiceGuidance && window.voiceGuidance.isEnabled()) {
            window.voiceGuidance.speakPhaseGuidance(phase.label, technique);
          }
        };
        
        // Helper to find current technique
        function findCurrentTechniqueName() {
          const techniqueButton = document.getElementById('techniqueButton');
          if (techniqueButton) {
            const text = techniqueButton.textContent.toLowerCase().trim();
            
            if (text.includes('resonance')) return 'resonance';
            if (text.includes('box')) return 'box';
            if (text.includes('4-7-8') || text.includes('478')) return '478';
            if (text.includes('sigh')) return 'physio-sigh';
          }
          
          return 'resonance'; // Default
        }
      }
      
      // Connect to technique selection
      function connectToTechniqueSelection() {
        // Override technique selection
        const techniqueButtons = document.querySelectorAll('.technique-panel button');
        techniqueButtons.forEach(btn => {
          const originalClick = btn.onclick;
          
          btn.onclick = function(e) {
            if (originalClick) {
              originalClick.call(this, e);
            }
            
            // Get selected technique
            const technique = btn.getAttribute('data-technique');
            if (!technique || technique === 'learn-more') return;
            
            // Apply technique-specific enhancements
            
            // Change color theme to match technique
            if (window.colorTherapy) {
              const theme = window.colorTherapy.getThemeForTechnique(technique);
              window.colorTherapy.setTheme(theme);
            }
            
            // Adapt sound to technique
            if (window.soundscapes) {
              window.soundscapes.adaptToTechnique(technique);
            }
            
            // Announce technique change
            if (window.voiceGuidance && window.voiceGuidance.isEnabled()) {
              window.voiceGuidance.speakMessage(`${technique} breathing selected.`);
            }
          };
        });
      }
      
      // Connect to session lifecycle
      function connectToSessionLifecycle() {
        // Start session tracking
        if (window.analytics) {
          // Prompt for initial mood
          setTimeout(() => {
            const technique = findCurrentTechniqueName();
            const sessionId = window.analytics.startSession(technique, state.sessionDuration);
            window.analytics.promptForMood('before');
          }, 3000);
        }
        
        // Helper to find current technique
        function findCurrentTechniqueName() {
          const techniqueButton = document.getElementById('techniqueButton');
          if (techniqueButton) {
            const text = techniqueButton.textContent.toLowerCase().trim();
            
            if (text.includes('resonance')) return 'resonance';
            if (text.includes('box')) return 'box';
            if (text.includes('4-7-8') || text.includes('478')) return '478';
            if (text.includes('sigh')) return 'physio-sigh';
          }
          
          return 'resonance'; // Default
        }
      }
      
      // Add subtle animations to UI elements
      function enhanceUIElements() {
        // Add styles for enhanced UI animations
        const style = document.createElement('style');
        style.textContent = `
          /* Button hover effects */
          .bottom-button, 
          .technique-panel button,
          .timer-options button,
          .session-progress {
            position: relative;
            overflow: hidden;
          }
          
          .bottom-button:after,
          .technique-panel button:after,
          .timer-options button:after,
          .session-progress:after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
              90deg, 
              transparent, 
              rgba(255,255,255,0.2), 
              transparent
            );
            transition: left 0.3s ease;
          }
          
          .bottom-button:hover:after,
          .technique-panel button:hover:after,
          .timer-options button:hover:after,
          .session-progress:hover:after {
            left: 100%;
          }
          
          /* Pulse animation for the timer display */
          .timer {
            animation: subtle-pulse 4s infinite ease-in-out;
          }
          
          @keyframes subtle-pulse {
            0% { opacity: 0.85; }
            50% { opacity: 1; }
            100% { opacity: 0.85; }
          }
          
          /* Make logo a bit more alive */
          .logo {
            transition: transform 0.5s ease;
          }
          
          .logo:hover {
            transform: scale(1.05);
          }
          
          /* Floating animation for breathing circle */
          .breathing-circle {
            animation: floating 6s infinite ease-in-out;
          }
          
          @keyframes floating {
            0% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-10px) scale(1); }
            100% { transform: translateY(0px) scale(1); }
          }
        `;
        
        document.head.appendChild(style);
      }
      
      // INITIALIZATION
      function init() {
        cacheElements();
        initializeAudio();
        attachEventListeners();
        detectSafariAndAdjust();
        
        // Set initial ARIA states
        utils.setAriaState(state.elements.focusButton, 'aria-pressed', false);
        utils.setAriaState(state.elements.techniqueButton, 'aria-expanded', false);
        
        // Hide the install button initially (will show when ready)
        if (state.elements.installButton) {
          state.elements.installButton.style.display = 'none';
        }
        
        // Register service worker for offline support if available
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            // Adjust path for GitHub Pages if needed
            const swPath = location.hostname === 'localhost' ? 
              '/service-worker.js' : 
              '/hagius-breathing/service-worker.js';
              
            navigator.serviceWorker.register(swPath)
              .then(registration => {
                console.log('ServiceWorker registered with scope:', registration.scope);
              })
              .catch(error => {
                console.log('ServiceWorker registration failed:', error);
              });
          });
        }
        
        // Initialize enhanced features
        enhanceBreathingApp();
      }
      
      // Safari detection and adjustment function
      function detectSafariAndAdjust() {
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        
        if (isSafari && isMac) {
          const circle = document.getElementById('holdProgressCircle');
          if (circle) {
            circle.setAttribute('r', '43');
            circle.setAttribute('stroke-dasharray', '270.2');
            
            const svg = circle.closest('svg');
            if (svg) {
              svg.style.width = '101%';
              svg.style.height = '101%';
              svg.style.left = '-0.5%';
              svg.style.top = '-0.5%';
            }
          }
        }
      }
      
      // Make functions available globally
      window.state = state;
      window.startBreathing = startBreathing;
      window.resetBreathing = resetBreathing;
      window.startPhase = startPhase;
      window.startSessionTimer = startSessionTimer;
      window.updateProgressBar = updateProgressBar;
      window.updateRemainingTimeDisplay = updateRemainingTimeDisplay;
      window.endSession = endSession;
      window.checkAllResourcesLoaded = checkAllResourcesLoaded;
      
      // Initialize the app when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
